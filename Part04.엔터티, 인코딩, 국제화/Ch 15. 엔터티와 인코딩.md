> 엔터티 (entity)
>
> 사람이 생각하는 개념이나 정보 단위와 같은 현실 세계의 대상체, 실세계에 존재하는 유형 혹은 무형 정보의 대상이며 서로 구별이 되는 하나하나의 대상



# 1. 메시지는 컨테이너, 엔터티는 화물

엔터티는 무엇일까. HTTP 메시지를 운송 시스템의 컨테이너라고 생각한다면, 엔터티는 메시지의 `실질적인 화물`이다. HTTP/1.1은 아래와 같은 10가지 주요 엔터티 헤더 필드를 정의한다.



## 1-1. 엔터티 헤더

##### Content-Type

엔터티에 의해 전달되는 객체의 종류

##### Content-Length

전달되는 메시지의 길이나 크기

##### Content-Language

전달되는 객체와 가장 잘 대응되는 자연어

##### Content-Encoding

객체 데이터에 대해 행해진 변형 (압축 등)

##### Content-Location

요청 시점을 기준으로, 객체의 또 다른 위치

##### Content-Range

보내는 엔터티가 부분 엔터티일 경우, 전체에서 어느 부분인지 명시함

##### Content-MD5

엔터티 본문의 콘텐츠에 대한 체크섬 (`무결성` 검사)

##### Last-Modified

서버에서 이 콘텐츠가 생성 혹은 수정된 날

##### Expires

이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각

##### Allow

이 리소스에 대해 허용되는 요청 메서드 목록



### 그 밖의 주요 헤더

##### ETag

이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.

##### Cache-Control

이 문서를 캐시하는 방법에 대한 지시자. 엔터티 헤더로 정의되어 있지는 않다.



## 1-2. 엔터티 본문

엔터티 본문은 `가공되지 않은 데이터`만을 담고 있다. 본문에 대한 다른 정보들은 모두 헤더에 담겨 있다. 데이터의 타입, 인코딩 여부 등을 통해 데이터의 해석 방법을 다르게 가져갈 수 있다.

엔터티 본문은 헤더 필드의 끝을 의미하는 `빈 CRLF` 줄 바로 다음부터 시작한다.





# 2. Content-Length: 엔터티의 길이

엔터티 본문의 크기를 바이트 단위로 나타낸다. 압축되었다면 압축된 후의 크기가 표시된다. 이 헤더는 메시지를 `청크 인코딩`으로 전송하지 않고 메시지가 엔터티 본문을 포함한다면 `필수적으로` 있어야 한다.



## 2-1. 잘림 검출

HTTP 옛날 버전에서는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다. 그러나 `Content-Length` 헤더가 없다면 커넥션이 정상적으로 닫힌 것인지 오류가 발생한 것인지 알 수 없다. 클라이언트는 `메시지 잘림`을 검출하기 위해 Content-Length를 필요로 한다.

캐싱 프락시 서버에서 잘린 메시지를 보관하게 될 경우 타격이 클 수 있다. 잘린 것인지도 모르고 결함이 있는 콘텐츠를 계속 제공할 것이기 때문이다. 이런 위험을 줄이기 위해, 캐싱 프락시 서버는 명시적으로 Content-Length 헤더가 없는 HTTP 본문은 보통 캐시하지 않는다.



## 2-2. 잘못된 Content-Length

Content-Length가 잘못된 값을 가지고 있을 경우 아예 없는 경우보다 큰 피해를 유발할 수 있다. 초기 클라이언트, 서버들은 이와 관련된 버그들을 갖고 있기 때문에, 몇몇 클라이언트, 서버, 프락시들은 서버가 이러한 오작동을 했는지 탐지하고 교정을 시도한다. 공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받았다는 사실을 인지했을 때 사용자에게 알려주게 되어 있다.



## 2-3. Content-Length와 지속 커넥션(Persistent Connection)

지속 커넥션을 유지한 상태라면 연속적으로 오는 메시지의 시작과 끝을 구분할 필요가 있다. 이를 위해 Content-Length 헤더가 사용되며 지속 커넥션을 위해 필수적으로 필요하다.

청크 인코딩을 사용하는 경우 Content-Length 헤더가 없지만 잘 정의된 크기의 조각들로 나누어 전송할 수 있다.



## 2-4. 콘텐츠 인코딩

엔터티 본문이 인코딩 혹은 압축되었을 경우 Content-Length는 인코딩 혹은 압축된 후의 길이를 담아야 한다. 어떤 애플리케이션은 이전의 크기를 보내기도 하는데, 이는 특히 지속 커넥션일 때 심각한 오류를 유발한다. 불행히도 HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 본문의 길이를 보내기 위해 사용될 수 없기 때문에 반드시 인코딩된 후의 길이를 보내야 한다.



## 2-5. 엔터티 본문 길이 판별을 위한 규칙

다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙들이다. 이 규칙들은 반드시 나열된 순서대로 적용되어야 한다.

- 본문을 갖지 않는 타입의 HTTP 메시지의 경우, Content-Length 헤더가 무시된다. 부가 정보에 불과하며 실제 본문 길이를 서술하지 않는다. 엔터티 본문을 금하는 HEAD같은 메시지는 Content-Length 헤더가 있더라도 반드시 헤더 이후의 첫 번째 빈 줄에서 끝나야 한다.
- 메시지가 `Transfer-Encoding` 헤더를 포함하고 있다면 메시지가 커넥션이 닫혀서 끝나지 않는 이상 엔터티는 `0 바이트 청크`라 불리는 특별한 패턴으로 끝나야 한다.
- 메시지가 Content-Length 헤더를 갖고 메시지 유형이 엔터티 본문을 허용한다면, Transfer-Encoding 헤더가 존재하지 않는 이상 본문의 길이를 담았다고 여긴다.
- 메시지가 `multipart/byteranges` 미디어 타입을 사용하고 Content-Length 헤더가 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의한다. 이 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다. 따라서 수신자가 이것을 해석할 수 있다는 사실을 알기 전까지는 보내지 않는 것이 규칙이었지만 HTTP/1.1 명세에서 삭제되었다.
- 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다. 실질적으로 서버만이 메시지가 끝났음을 알리기 위해 커넥션을 닫을 수 있다.
- HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을 가지고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다. HTTP/1.1 명세는 요청에 본문은 있지만 Content-Length 헤더는 없는 경우, 메시지의 길이를 판별할 수 없다면 `400 Bad Request` 응답을 보내고 유효한 Content-Length 헤더를 요구하고 싶다면 `411 Length Required` 응답을 보내라고 조언하고 있다.





# 3. 엔터티 요약

엔터티의 무결성 검사를 위해 `Content-MD5` 헤더를 사용할 수 있다. 응답을 처음 만든 서버만이 엔터티 본문에 `MD5 알고리즘`을 적용한 결과를 계산해서 보낸다.

서버는 엔터티 본문에 대해 인코딩 혹은 압축이 필요하다면 그 과정을 진행한 엔터티 본문에 대한 MD5를 Content-MD5 헤더에 담는다. 이후 전송할 때 본문에 대해 `전송 인코딩`이 적용되기 때문에 클라이언트는 먼저 전송 인코딩을 디코딩한 뒤 본문에 대한 MD5 디코딩을 진행한다.

메시지의 무결성 검사 뿐만 아니라 `문서의 위치`를 빠르게 알아내고 `콘텐츠의 중복 저장을 방지`하기 위한 해시 테이블의 키로 이용될 수 있지만 Content-MD5 헤더는 그다지 자주 전송되지 않는다.

HTTP의 확장들은 다른 요약 알고리즘을 제안했다. 이 확장들은 클라이언트가 응답에 대해 기대하는 `요약 유형`을 정의할 수 있는 새로운 헤더인 `Want-Digest`를 제안했다. 이 헤더에 `품질값(quality value)`을 이용해 여러 요약 알고리즘을 제안하고 각각에 대한 `선호도`를 지정할 수 있다.

```http
Want-Digest: sha-256
Want-Digest: SHA-512;q=0.3, sha-256;q=1, md5;q=0
```

현재는 이게 더 많이 쓰이는 것 같다.





# 4. 미디어 타입과 차셋(Charset)

`Content-Type` 헤더 필드는 엔터티 본문의 `MIME 타입`을 기술한다. MIME 타입은 전달되는 데이터 매체의 기저형식의 표준화된 이름이다. 이에 따라 클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리한다.

Content-Type의 값은 `인터넷 할당 번호 관리기관(Internet Assigned Numbers Authority, IANA)`에 등록된 표준화된 MIME 타입이다. MIME 타입은 `주 타입/부 타입` 형식으로 이루어져 있다. 엔터티가 인코딩을 거쳤더라도 인코딩 전의 타입이 기록되기 때문에 Content-Type은 중요하다고 볼 수 있다.



## 4-1. 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용 유형을 `더 자세히 지정하기 위해` 선택적으로 매개변수를 넣어줄 수 있다. 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 `charset`이 대표적인 예이다.

```http
Content-Type: text/html; charset=iso-8859-4
```



## 4-2. 멀티파트

`멀티파트`는 여러 개의 MIME 타입으로 이루어진 문서를 보낼 때 사용한다. HTTP는 멀티파트 본문을 폼을 채워서 제출하거나, 문서의 일부분을 실어 나르는 범위 응답을 할 때 사용한다.



### 4-2-1. 멀티파트 폼 제출

HTTP 폼을 채워서 제출하면, `가변 길이 텍스트 필드`와 `업로드 될 객체(이미지 등)`는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.

```http
Content-Type: multipart/form-data; boundary=[abcdefghijklmnopqrstuvwxyz]
```

이 때, `boundary`는 서로 다른 파트를 구분하기 위해 사용된다.



### 4-2-2. 멀티파트 범위 응답

범위 응답을 할 때는 `Content-Type: multipart/byteranges` 헤더와 멀티파트 본문이 함께 온다.

> `MIME(Multipurpose Internet Mail Extensions)`
>
> 기본적으로 `이메일`을 위해 정의된 것이다. 영어가 아닌 언어나 파일을 이메일로 보내기 위해 고안되었으며, HTTP나 SIP같은 인터넷 프로토콜에도 사용되고 있다.





# 5. 콘텐츠 인코딩

HTTP 애플리이션은 압축, 암호화 등의 인코딩 작업을 콘텐츠를 보내기 전에 하려고 한다. 콘텐츠 인코딩이 끝난 데이터는 엔터티 본문에 담아 보내진다.



## 5-1. 콘텐츠 인코딩 과정

1. 웹 서버가 원본 `Content-Type`과 `Content-Length` 헤더를 수반한 원본 응답 메시지를 생성한다.
2. `콘텐츠 인코딩 서버` (원 서버 or 다운스트림 프락시)가 `인코딩된 메시지`를 생성한다. 인코딩된 메시지에 따라 Content-Type은 변하지 않지만 Content-Length는 변한다. 콘텐츠 인코딩 서버는 `Content-Encoding` 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 메시지를 디코딩할 수 있도록 한다.
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.



## 5-2. 콘텐츠 인코딩 유형

HTTP는 몇 가지 `표준 콘텐츠 인코딩 유형`을 정의하지만 확장 인코딩으로 인코딩하는 것도 허용한다. 인코딩은 각 콘텐츠 인코딩 알고리즘에 `고유한 토큰`을 할당하는 `IANA`를 통해 표준화된다. Content-Encoding 헤더에 이 토큰값을 기술한다.

| 콘텐츠 인코딩 값 | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| gzip             | 엔터티에 GNU zip 인코딩이 적용되었음                         |
| compress         | 엔터티에 유닉스 압축 프로그램인 compress가 적용되었음        |
| deflate          | 엔터티가 zlib 포맷으로 압축되었음                            |
| identity         | 어떤 인코딩도 수행되지 않음. Content-Encoding 헤더가 존재하지 않는다면 이 값인 것으로 간주 |



## 5-3. Accept-Encoding 헤더

서버에서 인코딩한 본문을 클라이언트가 해석하지 못하는 일이 발생하지 않도록하기 위해 클라이언트는 자신이 인코딩할 수 있는 방법들을 `Accept-Encoding` 헤더에 기술한다. 만약 이 헤더를 포함하지 않고 요청을 보낼 경우 서버는 클라이언트가 `어떤 인코딩이든 받아들일 수 있다`고 간주한다.

```http
Accept-Encoding: compress, gzip
Accept-Encoding: * (안 보낸 것과 동일하다)
Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0
```

클라이언트는 각 인코딩에 `Q(quality)` 값을 매개변수로 더해 선호도를 나타낼 수 있다. 범위는 `0.0`에서 `1.0`이다.

`identity` 인코딩 토큰은 오직 `Accept-Encoding` 헤더에만 존재할 수 있다. 클라이언트에 의해 다른 콘텐츠 인코딩 알고리즘에 대해 `상대적 선호도`를 정의하는 데 이용될 수 있다.





# 6. 전송 인코딩과 청크 인코딩

콘텐츠 인코딩과는 다르게 `전송 인코딩`은 콘텐츠 포맷과는 독립적이다. 엔터티 본문에 적용되긴 하지만 `구조적인 이유` 때문에 적용되는 것이며, 메시지 데이터가 네트워크를 통해 `전송되는 방법`을 바꾼다.

> `콘텐츠 인코딩 vs 전송 인코딩`
>
> 콘텐츠 인코딩은 메시지의 `엔터티 부분`만 인코딩하는 반면, 전송 인코딩은 `전체 메시지`에 적용되어 메시지 자체의 구조를 바꾼다.



## 6-1. 안전한 전송

전송 인코딩은 `안전한 전송`을 위해 존재한다. 표준화되고 더 너그러운 전송 기반을 갖춘 HTTP는 안전한 전송의 초점을 다른 데에 둔다. HTTP에서 전송된 본문이 문제를 일으키는 경우는 별로 없는데, 그 중 두 가지가 다음과 같다.

##### 알 수 없는 크기

몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 생성하기 전까지는 메시지 본문의 최종 크기를 알 수 없다. 하지만 이 서버들은 보통 사이즈를 알기 전에 전송을 시작하려고 한다. HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에 몇몇 서버는 정확한 Content-Length 헤더를 통해서가 아닌, `특별한 종결 꼬리말`을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.

##### 보안

공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞여버리기도 한다. 하지만 이미 `SSL`과 같은 유명한 전송 계층 보안 방식이 있기 때문에 거의 일어나지 않는다.



## 6-2. Transfer-Encoding 헤더

전송 인코딩을 위해 정의된 헤더는 두 개뿐이다.

##### Transfer-Encoding

안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.

##### TE

클라이언트가 어떤 `확장된 전송 인코딩`을 사용할 수 있는지 서버에게 알려주기 위해 사용하는 `요청 헤더`이다.

```http
요청 헤더의 예

GET /new_product.html HTTP/1.1
...
TE: trailers, chunked
```

```http
응답 헤더의 예

HTTP/1.1 200 OK
...
Transfer-Encoding: chunked
```

모든 전송 인코딩 값은 대소문자를 구별한다. 최신 HTTP 명세는 전송 인코딩으로 `청크 인코딩` 하나만 정의했다. HTTP/1.1에서 청크 인코딩은 언제나 `acceptable`하므로 굳이 TE에 명세하지 않아도 된다.

TE 헤더도 각 인코딩별 선호도를 Q 값으로 지정할 수 있다. HTTP/1.1에서는 chunked의 Q 값이 0.0인 것을 금지하고 있다.



## 6-3. 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 `청크` 여럿으로 쪼갠다. 서버는 각 청크를 `순차적으로` 보낸다. 본문이 동적으로 생성됨에 따라, 서버는 그 중 일부를 버퍼에 담은 뒤 한 청크를 청크의 크기와 함께 보낸다. 본문 전체를 모두 보낼 때까지 반복한다.



### 6-3-1. 청크와 지속 커넥션

청크 인코딩은 본문을 모두 보내면 `크기가 0인 청크`로 본문이 끝났음을 알리는 방식으로 클라이언트에게 알려준다.



### 6-3-2. 청크 인코딩 구조

> 1. HTTP 응답 헤더 블록
> 2. 청크의 스트림
> 3. 마지막 청크
> 4. 트레일러 (메시지 헤더에 Trailer 헤더가 있을 때만 존재)

위와 같은 순서로 인코딩된 메시지가 전송된다. 스트림은 `청크의 크기, CRLF 문자열, 데이터, CRLF 문자열` 순으로 나열된다. 청크의 크기는 CRLF 문자열을 제외한 크기를 나타낸다.

클라이언트가 서버에 청크 인코딩된 데이터를 보낼 수도 있다. 이 때, 서버는 `TE 헤더`를 보내지 않기 때문에 클라이언트는 청크 요청이 `411 Length Required` 응답으로 거절당하는 것에 대비해야 한다.



### 6-3-3. 청크 인코딩된 메시지의 트레일러

다음 중 하나 이상의 조건을 만족하면 청크 메시지에 `트레일러`를 추가할 수 있다.

- 클라이언트의 `TE 헤더`가 트레일러를 `받아들일 수 있음`을 나타내고 있는 경우
- 트레일러가 응답을 만든 `서버에 의해 추가`되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 `선택적인 메타데이터`여서 클라이언트가 `무시하고 버려도 되는` 경우

트레일러에는 메시지 시작 시점에서는 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다. 예로는 `Content-MD5` 헤더가 있다. 문서가 생성되기 전에 그 문서의 MD5를 계산하는 것은 어렵기 때문이다.

Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 HTTP 헤더도 트레일러로 보낼 수 있다.



## 6-4. 콘텐츠와 전송 인코딩의 조합

`콘텐츠 인코딩`과 `전송 인코딩`은 동시에 사용될 수 있다. 콘텐츠 인코딩이 이루어진 메시지 본문에 전송 인코딩이 사용된다. 수신자가 본문을 디코딩하는 과정은 반대의 순서로 진행된다.



## 6-5. 전송 인코딩 규칙

전송 인코딩이 메시지 본문에 적용될 때, 몇 가지 규칙이 반드시 적용되어야 한다.

- 전송 인코딩의 집합은 반드시 `chunked`를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 `마지막 전송 인코딩`이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

전송 인코딩은 HTTP/1.1에 소개된 비교적 새로운 기능이기 때문에 그 이하 버전의 애플리케이션에 인코딩된 메시지를 보내지 않도록 유의해야 한다. 서버의 경우 이해할 수 없는 인코딩 방식이라면 `501 Unimplemented` 상태 코드로 응답해야 한다.





# 7. 시간에 따라 바뀌는 인스턴스

웹 객체는 정적이지 않다. 시시각각 변한다. HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것을 `인스턴스 조작(instance manipulation)`이라 부르며 객체의 인스턴스에 작용한다. 이들 중 대표적인 두 가지가 `범위 요청`과 `델타 인코딩`이다.

이 둘 모두, 클라이언트의 사본과 서버의 리소스를 비교해 같은지 판단하고 상황에 따라 새 인스턴스를 요청할 수 있는 메커니즘이다.





# 8. 검사기와 신선도

7장 캐시를 참조하자.





# 9. 범위 요청

HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 한다. 특정 컨텐츠를 다운받다가 커넥션에 오류가 있어 연결이 끊겼을 때, 이미 받은 부분을 제외한 부분만 요청할 수 있는 것이 한 예가 될 수 있겠다.

```http
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (winNT; 1)
```

위 예에서 클라이언트는 처음 4,000 바이트 이후의 부분을 요청하고 있다. 문서의 크기를 모르기 때문에, 끝 부분은 명시하지 않는다.

Range 헤더는 또한 여러 범위로 요청을 하기 위해 이용될 수 있다. 각 범위는 순서가 없고 겹칠 수도 있다. 한 문서를 빠르게 다운받기 위해 동시에 여러 서버에 접속해서 다운받는 상황이라면, 응답은 `멀티파트 본문`과 `Content-Type: byteranges` 헤더와 함께 하나의 엔터티로 돌아온다.

```http
HTTP/1.1 200 OK
...
Content-Range: bytes=4000-
Accept-Ranges: bytes
```

위는 서버 응답의 한 예이다. 서버는 클라이언트에게 `Accept-Ranges` 헤더를 통해 어떤 `측정의 단위`로 범위를 받아들일 수 있는지 알려 준다. 이 경우처럼 주로 `바이트`를 단위로 사용한다. 또한 `Content-Range`를 통해 응답하는 리소스의 범위를 알려 준다.

범위 요청은 객체의 특정 인스턴스를 클라이언트와 서버가 교환하는 일이다. 따라서 클라이언트와 서버가 `같은 버전의 문서`를 갖고 있을 때에만 의미가 있다.





# 10. 델타 인코딩

델타 인코딩은 객체 전체가 아닌 `변경된 부분`에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다. 델타 인코딩도 일종의 인스턴스 조작인데, 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 때문이다.

> 1. 클라이언트의 최초 요청
> 클라이언트가 리소스를 최초로 요청한다. 요청받은 문서를 캐시한다.
> 2. 서버 응답
> 서버는 최신 버전의 문서를 보낸다.
> 3. 클라이언트의 재요청 with `델타`
> 클라이언트는 캐싱한 문서가 만료되었다는 것을 알고 서버에게 다시 요청을 보낸다. 이 때, `A-IM` 헤더를 포함한 요청을 보내 자신이 델타를 받아들이겠다는 의지를 서버에게 알린다.
> 4. 서버 응답
> 델타를 계산해서 클라이언트에게 응답한다.

##### A-IM 헤더

클라이언트는 서버에게 `A-IM(Accept-Instance-Manipulation)` 헤더를 보내서 자신이 델타를 받아들일 수 있음을 알린다. 이 때, 델타를 계산하고 델타를 이용해 최신 문서를 생성하는 알고리즘을 헤더에 명시한다.

##### 서버 응답 with IM 헤더

서버는 아래와 같은 요소들을 포함한 응답을 클라이언트에게 보낸다.

- 객체 자체가 아닌 인스턴스 조작을 보내고 있음을 말해주는 응답 코드 `226 IM Used`
- 새로운 `ETag` 헤더
- 델타를 계산할 때 기반이 된 문서의 `ETag`(이상적인 경우 클라이언트의 `If-None-Match` 요청 헤더에 있던 값과 같다)를 지정한 `Delta-Base` 헤더



## 10-1. 인스턴스 조작, 델타 생성기 그리고 델타 적용기

서버의 `델타 생성기`는 기저 문서와 그 문서의 최신 인스턴스를 취하여 클라이언트의 `A-IM` 헤더에 지정된 알고리즘을 이용해 둘 사이의 델타를 계산한다.

클라이언트의 `델타 적용기`는 델타를 취하여 그를 기저 문서에 적용하여 문서의 최신 인스턴스를 생성한다.

변경점만을 보내기 때문에 트래픽의 많은 부분을 절약할 수 있지만 델타 인코딩이 항상 좋은 것만은 아니다. 클라이언트에게 이전 버전의 문서와 다른 부분만을 보내줘야 하기 때문에 서버는 모든 버전의 문서를 가지고 있어야 한다. 변경이 잦은 문서의 경우 과거 사본을 모두 유지하기 위해 늘려야 하는 디스크 공간이 많을 수 있다. 이는 트래픽 감소라는 이점을 무의미하게 만들 수 있다.

