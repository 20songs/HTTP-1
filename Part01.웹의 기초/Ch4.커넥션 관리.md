# Ch4.커넥션 관리

#### 4.1 TCP 커넥션

```
- HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집한인 TCP/IP로 구성
- 일단 커넷션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고 받는 메시지는 안전하게 전달
```

  

##### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

```
- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공하고 바이트의 반대 순서로 전달
ex) 'GET/index' 클라이언트---'xedni/TEG'전달---> 서버 
```



##### 4.1.2 TCP 스트림은 세그먼트로 나눠어 IP 패킷을 통해 전송된다

![4. 커넥션 관리](Ch4.커넥션 관리.assets/http-1-14.png)

```
- HTTP는 'IP','TCP','HTTP'로 구성된 프로토콜 스택
- HTTPS는 'IP','TCP','TLS or SSL','HTTP'로 구성 ('TLS or SSL'는 암호화된 계층)
```

``` 
- TCP는 데이터 스트림을 세크먼트 단위로 나누고 IP 패킷이라는 봉투에 담아 인터넷을 통해 데이터 전달 이 과정는 HTTP 프로그래머에게 보이지 않음 
```



##### 4.1.3 TCP 커넥션 유지하기

````
- 컴퓨터는 포트번호를 통해 여러개의 TCP 커넥션을 유지
- TCP 커넥션은 `발신지 IP주소`, `발신지 포트`, `수신지 IP주소`, `수신지 포트` 값으로 유일한 커넥션 생성 (항복 별로는 중복 허용)
````



##### 4.1.4 TCP 소켓 프로그래밍

```
소켓 API로 TCP 종단(endpoint) 데이터 구조 생성, 원격 서버의 TCP 종단에 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸수 있음
```

<img src="Ch4.커넥션 관리.assets/20160908103155325.png" alt="img" style="zoom:80%;" />





#### 4.2 TCP의 성능에 대한 고려

##### HTTP 트랜잭션 지연

```
서버가 많은 데이터, 복잡하고 동적인 자원을 실행하지 않은 한 대부분의 HTTP 지연은 TCP 네트워트 지연으로 발생됨
```

- 원인 

  ````\
  최근 미방문한 호스트에는 DNS 이름 분석 인트라를 사용하여 URL에 있는 호스트 명을 IP 주소로 변환 하는데 시간 소요
  ````

  ```
  커넥션 설정 시간은 1~2초 시간이 소요되지만 수백의 HTTP 트랜잭션이 만들어지면 소요 시간 크게 증가
  ```

  ```
  클라이언트가 TCP 파이프를 통해 요청을 전송하고 TCP 커넥션이 요청 메시지를 읽고 처리하기 까지 시간이 소요
  ```

  ```
  웹 서버가 HTTP 응답을 보내는데 시간 소요
  ```



##### 4.2.2 성능 관련 중요 요소

1. TCP 커넥션의 핸드셰이크 설정 

2. 인터넷의 혼잡을 제거하기 위한 TCP의 느린 시작 

3. 데이터를 한데 모아 한 번에 전송하기 위한 네이글 알고리즘

4. TCP 편승 확인 응합을 위한 확인응답 지연 알고리즘

5. TIME_WAIT 지연과 포트 고갈

   

##### 4.2.3 TCP 커넥션 핸드셰이크 지연 `1`

<img src="Ch4.커넥션 관리.assets/6.jpg" alt="커넥션 관리 - TCP 커넥션과 성능 | 필오의 개발일지" style="zoom: 67%;" />

```
1. 새로운 TCP 커넥션을 생성하기 위해 클라이언트는 서버에게 'SYN'플래그를 갖는 패킷 요청
2. 서버는 커넥션을 받고 요청이 성공하면 'SYN + ACK' 플래그를 클라이언트에게 전송
3. 클라이언트는 커넥션을 잘 맺어졌음을 알리기 위해 확인응답 신호와 함께 'ACK' 전송
   이때 요청 메시지 전체를 전달 할 수 있을 만큼 큰 경우가 많음
```





##### 4.2.4 확인응답 지연 `2`

###### TCP 자체적인 데이터 전송 확인 체계

```
- 수신자는 세크먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환하고 특정시간 안에 송신자가 받지 않으면 오류가 있다고 판단하여 데이터 재전송
- 확인 응답은 크기가 작아서 송출 데이터 패킷에 확인응답을 편승하여 효율적으로 사용
```

###### 확인응답지연 알고리즘

```
- 송출할 확인응답을 특정 시간 동안 버퍼에 저장 후 편승시킬 송출 데이터 패킷을 찾음, 만약 찾지 못하면 별도 패킷을 만들어 전송
```

###### 확인응답지연 알고리즘 수정 및 비활성화

````
- 해당 방향으로 송출될 패킷이 많지 않기 때문에 지연이 자주 발생하여 운영체제 따라 관련 기능을 수정하거나 비활성화 가능
- 만약 위 기능을 수정하려 한다면 TCP 내부 알고리즘이 피하려고 하는 문제를 애플리케이션이 발생시키지 않을 것이라는 확신 필요!
````



##### 4.2.5 TCP 느린 시작 `3` 

###### TCP 느린시작

````
- TCP 느린 시작은 인터넷의 급작스러운 부하와 혼잡을 방지하기 위해 처음에 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한을 높이는 것
````

###### 혼잡 윈도우를 연다

```
- 패킷이 성공적으로 전달 후 확인응답을 받으면 2개의 패킷을 추가로 전송할 권리를 얻는 것
```



##### 4.2.6 네이글(Nagle) 알고리즘과 TCP `4` 

###### 네이글 알고리즘

```
- 네이글 알고리즘은 패킷을 전송하기 전 TCP 데이터를 한 개의 덩어리로 합침
- 세크먼트가 최대 크기가 되지 않으면 전송을 하지 않음 
- 다른 모든 패킷이 전송중이면 데이터는 버퍼에 저장됨
- 만약 다른모든 패킷이 확인응답을 받은 경우에는 미달 크기의 패킷 전송도 허용
```

###### 네이글 알고리즘 문제

```
- 패킷을 채우지 못하면 추가적인 데이터를 기다리기때문에 지연 발생
- 확인응답지연과 함께 쓰일 경우, 네이글 알고리즘은 응답이 도착할 때까지 데이터 전송 멈추고 / 확인 응답 알고리즘은 확인응답을 지연
```

###### 네이글 알고리즘 비활성화

```
- TCP_NODELAY 파라미터 값을 설정하여 비활성화 하기도 하지만 작은 크기의 패킷이 대량 생산되는 것을 방지하기 위해 큰 크기의 데이터 덩어리 만들어야 함
```



##### 4.2.7 TIME_WAIT의 누적과 포트 고갈 `5` 

```
- 문제는 실제 상황보다는 성능 측정할 때 발생 
- 같은 주소와 포트번호를 사용하는 새로운 TCP 커넥션에 삽입이 되면 패킷은 중복되고 TCP 데이터가 충돌
- 위 문제를 일정 시간 동안 생성못하게 방지하기 위해 메모리의 작은 제어영역에 정보를 기록
- 만약 트랜젝션을 초당 500개 이상 처리 하지 못하면 발생하지 않음
```

###### TIME_WAIT 포트고갈 방지 방법

```
- 부하를 생성하는 장비를 더 많이 사용
- 여러 개의 가상 IP 주소 사용 
```





#### 4.3 HTTP 커넥션 관리

##### 4.3.1 흔히 잘못 이해하는 Connection 헤더

```
- Http 메시지는 클라이언트와 서버 사이 중개 서버를 거치며 전달
- HTTP Connection 헤더 필드는 현재 맺고 있는 커넥션에만 적용하고 다른 커넥션에는 전달되지 않음 
```

######  Connection 헤더 종류

```
[Connection : 필드 명, 토큰 값, close]
- HTTP 필드명 = 이 커넥션에만 해당되는 헤더
- 임시적 토큰 값 = 커넥션에 대한 비표준 옵션
- close = 커넥션이 작업이 완료되면 종료됨
```

###### Connection 헤더 특징

``` 
- Connection 헤더에 있는 모든 헤더 필드는 메시지가 전달되는 시점에 삭제 =홉별(hop-by-hop) 헤더 명
- connection 헤더와 메시지가 전달되면 기술되어 있는 모든 옵션 적용 후 connection 헤더와 기술되어 있는 모든 헤더 삭제
- connection 헤더에 기술되지 않더라도 홉별 헤더인 것도 있음
```



##### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

```
- 커넥션 관리 == TCP 성능
- 순차적 로드는 물리적 지연 뿐만 아니라 실시간으로 변화가 눈에 보이지 않는 심리적 지연도 있음
```

###### HTTP 커넥션 성능 향상시키는 기술

1. 병렬(parallel) 커넥션 : 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
2. 지속(persistent) 커넥션 : 컨넥션을 맞고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션 재활용
3. 파이프라인(pipelined) 커넥션 : 공유 TCP 커넥션을 통한 병렬 HTTP 요청
4. 다중(multiplexed) 커넥션 : 요청과 응답들에 대한 중재(실험적 기술)





#### 4.4 병렬 커넥션 `1`

````
- HTTP는 클라이언트가 여러 개의 커넥션을 맺어서 HTTP 트렌잭션을 병렬로 처리 할 수 있음
- 웹 내부의 컴포넌트가 항상 같은 서버에 호스팅되는 것이 아니라 여러 개의 서버와 맺어질 수 있음
````



##### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

```
-하나의 커넥션으로 객체를 로드할 때 대역폭 제한과 대기 시간을 줄여 더 빠르게 할 수 있음
- 각 커넥션의 지연 시간을 겹치게해서 총 지연시간을 줄임
```



##### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

```
- 네트워크 대역폭이 좁을 때 객체를 전송받는 것이 느리기 때문에 장점이 사라짐
- 다수의 커넥션은 메모리를 많이 소모, 자체적인 성능 문제 발생시킴, 고부하 프락시에도 동일하게 발생
- 실제로 병렬 커넥션은 적은 수(대부분 4개)만 허용
- 과도한 수의 커넥션을 맺은 경우 서버가 임의로 끊을 수 있음
```



##### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

```
- 병렬 커넥션이 실제로 더 빠르게 페이지를 내려 받는 것은 아니지만 여러 객체가 동시에 보이고, 내려받는 상황을 볼 수 있기 때문에 사용자는 더 빠르다고 여김
```





#### 4.5 지속 커넥션 `2`

###### 사이트 지역성

```
- 서버에 HTTP 요청을 하기 시작한 애플리케이션이 그 서버에 또 요청하게 되는 속성
```

###### 지속 커넥션

```
- 클라이언트나 서버가 커넥션을 끊기 전까지 트랜젝션 간에도 커넥션을 유지하여 재사용 가능
- 사전 준비 작업 시간을 절약하고 TCP 느린 시작으로 인한 지연을 피함
```



##### 4.5.1 지속 커넥션 vs 병렬 커넥션

###### 병렬 커넥션 단점

````
- 트랜잭션 마다 새로운 커넥션을 맺고 끊음으로 시간과 대역폭이 소요
- 새로운 커넥션은 TCP 느린시작으로 인해 성능 저하
- 실제 연결 할 수 있는 병렬 커넥션 수는 제한됨
````

###### 지속 커넥션 장점

````
- 사전 작업과 지연을 줄여줌
- 튜닝된 커넥션 유지
- 커넥션 수를 줄여줌
````

###### 지속 커넥션을 잘못 관리한 경우

````
- 수 많은 커넥션이 쌓임
- 클라이언트와 서버의 리소스에 불필요한 소모 발생
````



##### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

```
- 지속 커넥션은 상호 운용과 관련된 설계에 문제가 있지만 HTTP/1.1에서 수정됨 
- 많은 클라이언트와 서버가 초기의 Keep-Alive 커넥션을 사용 하고 있고 있어서 대응할 수 있어야함
```



##### 4.5.3 Keep-Alive 동작

```
- Keep-Alive는 HTTP/1.1명세에서 빠짐
- 아직도 Keep-Alive 핸드셰이크가 널리 사용 중이라 처리 할 수 있게 개발해야 함
- 요청에 Connection : Keep-Alive 해더를 포함하고 다음 요청에도 받고자 한다면 해더에 포함시켜 응답
```



##### 4.5.4 Keep-Alive 옵션

````
- Keep-Alive는 강제성 X, 요청일뿐
- 언제든 끊을 수 있고 처리되는 트랜잭션의 수를 제한 가능
````

###### Keep-Alive 응답 헤더 옵션

````
- timeout= n(초) : 커넥션이 몇 초간 유지될 것인가
- max= n(개) : 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인가
````



##### 4.5.5 Keep-Alive 커넥션 제한과 규칙

```
- Keep-Alive는 HTTP/1.0에서 기본으로 사용되지 않음
- 커넥션을 유지하려면 모든 메시지에 Connection:Keep-Alive 헤더 포함해야 함
```



##### 4.5.6 Keep-Alive와 멍청한(dumb) 

```
- 프락시는 Connection 헤더를 이해하지 못하서 헤더를 삭제하지 못하고 다음 프락시에 전달함
이로인해 브라우저나 서버는 자신의 타임아웃이 나서 커넥션이 끊길 때까지 요청을 받지 못한채 기다림
- 따라서 프락시는 절대 Connection헤더와 Connection 헤더에 명시된 헤더를 전달하면 안됨
```



##### 4.5.7 Proxy-Connection 살펴보기

###### Proxy-Connection

```
- 프락시를 별도로 설정할 수 있는 현대의 브라우저들에서 지원하고 있고 많은 프락시들도 이것을 인식함
```

###### 영리한 프락시

```
- Proxy-Connection헤더를 Connection 헤더로 바꾸면서 원하는 효과를 얻음
- 단, 멍청한 프락시의 양옆에 영리한 프락시가 있다면 문제 발생
```



##### 4.5.8 HTTP/1.1 의 지속 커넥션

```
- HTTP/1.1은 지속 커넥션을 기본적으로 활성화해서 끊으려면 Connection:close 헤더 명시
```



##### 4.5.8 지속 커넥션의 제한과 규칙

```
- 추가 요청을 하지 않는다면 Connection:close 헤더 명시
- HTTP/1.1 프락시 서버는 클라이언트의 지원 범위를 알고 있지 않는 한 지속 커넥션을 맺으면 안됨
- 서버는 메시지를 전송하는 중간에 커넥션을 끊지 않지만 HTTP/1.1은 Connection 헤더와 상관없이 언제든 끊을 수 있음
- 클라이언트는 서버의 과부하를 방지하기 위해 넉넉잡아 2개 지속 커넥션만 유지
```





#### 4.6 파이프라인 커넥션 `3`

```
- 요청을 파이프라이닝을 하여 Keep-Alie 커넥션 성능을 높임
- 여러 개의 요청을 응답이 도착하기 전까지 큐에 쌓고 전 요청이 서버에 전달되면 이어서 다음 요청을 전달
```

###### 파이프라인 커넥션의 제약사항

```
- 지속 커넥션을 확인하기 전에는 파이프라인을 이어서는 안됨
- 응답은 요청 순서와 같아야함
- 완료하지 않은 요청은 커넥션을 다시 맺고 요청 보낼 준비를 해야함
- 클라이언트는 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안됨
```





#### 4.7 커넥션 끊기에 대한 미스터리

```
- 커넥션 관리에 대한 명확한 기준이 없음
```



##### 4.7.1 '마음대로' 커넥션 끊기

```
- 클라이언트, 서버, 프락시는 언제든 TCP 전송 커넥션을 임의로 끊을 수 있음
```



##### 4.7.2 Content-Length와 Truncation

```
- HTTP 응답은 Content-Length 헤더를 가지고 있어야 함
- 커넥션이 끊어지거나 생략되어 잘못된 길이를 응답했다면 서버에게 정확한 길이 물어봐야함
- 수신자가 캐시 프락시인 경우 응답을 캐시하지 말고 메시지를 그대로 전달해야 함
```



##### 4.7.3 커넥션 끊기를 허용, 재시도, 멱등성

```
- 멱등: 실행 횟수에 상관 없이 같은 결과를 반환하는 트랜잭션
ex) GET, HEAD, PUT, DELETE, TRACE, OPTIONS 메서드
- 비멱등 : 횟수에 따라 결과가 달라지는 트랜잭션, (파이프라인 요청하면 안됨)
ex) POST
```



##### 4.7.4 우아한 커넥션 끊기

###### 전체 끊기

```
- TCP 커넥션의 입출력 채널 모두 끊는다
- close()
```

###### 절반 끊기

``` 
- 입력과 출력 채널 중 하나를 개별적으로 끊음
- shutdown()
```

###### TCP 끊기와 리셋 에러

```
- '전체 끊기'만을 사용할 수 있지만 예상치 못한 에러를 발지하기 위해 '절반 끊기'를 사용
- 출력 채널을 끊는 것이 안전
- 입력 채널은 더이상 데이터를 보내지 않을 확신이 없다면 위험
```

###### 우아하게 커넥션 끊기

```
- 자신의 출력 채널을 끊고 다른 쪽 기기의 출력 채넣이 끊기는 것을 기다린 후 양쪽에서 데이터를 전송하지 않을 것임을 알리면 온전히 종료
- 상대방이 절반 끊기를 구현했는지 보장이 없기 때문에 끊고자 하는 애플리케이션의 출력 채널을 끊고 난 후 데이터나 스트림의 끈을 식별하기 위해 입력 채널에 상태 검사를 주기적으로 해야함
```





