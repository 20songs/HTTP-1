# ch13.다이제스트 인증

> 다이제스트 인증

- 기본 인증과 호환되는 더 안전한 대체재
- 널리 사용되지는 않지만 개념은 보안 트랜잭션을 구현하는데 유용



## 1. 다이제스트 인증의 개선점

```
 비밀번호를 네트워크를 통해 평문으로 전송 X

- 인증 체결 가로채서 재현하려는 악의적인 사람 차단

- 구현에 따라 메시지 내용 위조 방지 가능
```



#### 절대로 비밀번호를 네트워크를 통해 보내지 않는다

- 클라이언트와 서버를 둘다 비번을 가지고 있음

- 서로가 보낸 요약이 비번에 알맞게 대응되는지 검사 --> 은행 보안카드 사용와 비슷한 개념

  <img src="ch13.다이제스트 인증.assets/image-20201010234652894.png" alt="image-20201010234652894" style="zoom:50%;" />



#### 단방향 요약

- 정보 본문의 압축

- MD5 : 임의의 바이트 배열을 원래 길이와 상관없이 128 비트로 요약하여 변환
  - 종종 32글자의 16진수 문자로 표현
  - 충돌 : 다른 입력값이지만 같은 값으로 변환될 때가 있지만 확률이 무시할 만큼 작음
  
- 요약함수 == 암호 체크섬(cyptographic checksums)

  - 단방향 해시함수 또는 지문함수

    

#### 재전송을 방지하기 위한 난스(nonce)

- 단방향 요약의 재전송이 가능하다면 여러번의 시도로 비번처럼 사용 가능
- 서버는 재전송 공격을 방지하기 위해  자주 바뀌는 증표인 난스를 클라이언트에게 건냄
- 서버가 클라이언트에게 난스를 비번화 섞어서 요약을 만듬



#### 다이제스트 인증 핸드셰이크

<img src="ch13.다이제스트 인증.assets/image-20201010234305845.png" alt="image-20201010234305845" style="zoom:60%;" />

< 상세 설명>

<img src="ch13.다이제스트 인증.assets/image-20201010234329150.png" alt="image-20201010234329150" style="zoom:50%;" />

<img src="ch13.다이제스트 인증.assets/image-20201010234355333.png" alt="image-20201010234355333" style="zoom:50%;" />

<img src="ch13.다이제스트 인증.assets/image-20201010234457493.png" alt="image-20201010234457493" style="zoom:50%;" />



## 2. 요약 계산

> 다이제스트 인증 핵심

```
[공개된 정보 / 비밀 정보 / 시한부 난스] 값을 조합한 단방향 요약
```

*RFC 2069 초기버번  --> RFC 2617 책 내용 --> RFC 7616  SHA-512-256,SHA-256 알고리즘 추가*



### 요약 알고리즘과 입력 데이터

1. action 함수:

   - 단방향 해시 함수 H(d)
   - 요약 함수 KD(s,d)  [s는 비밀, d는 data]

2. core 데이터:

   - 보안정보 데이터

     - 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 (**A1**)

       ```
       # 알고리즘
       A1 = <사용자이름>:<영역>:<비밀번호>
       ```

       ```
       # 알고리즘-sess
       A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스>
       ```

       

   - 요청메세지의 비밀 외의 속성 데이터

     - 요청 메세지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리 (**A2**)

       요청 URL과 URL지시자 값은 항상 같아야 한다

       ```
       # qop = auth
       A2 = <요청 메서드>:<url 지시자 값>
       ```

       ```
       # qop = auth-int
       A2 = <요청 메서드>:<url 지시자 값>:H(<요청 엔터티 본문>)
       ```

       

### 요약 알고리즘 전반

주어진 H, KD, A1, A2로 요약을 계산하는 방법

```
# qop = auth or auth-int  # nc: 난스 횟수 집계
response = KD(H(A1),unq(난스):<nc>:<unq(cnonce)>:<unq(qop)>:H(A2)) 
```



### 다이제스트 인증 세션

- 어떤 보호 공간을 위한 `WWW-Authenticate` 인증요구에 대한 클라이언트는
  그 보호 공간에 대해 인증 세션 을 시작하게 한다.

  - 보호 공간은 접근 중인 서버의 루트(canonial root)와 영역의 결합으로 정의된다.

- 인증세션은 클라이언트가 보호공간의 다른 서버로부터 
  또 다른`WWW-Authenticate` 인증요구를 받을 때까지 지속된다.

  - 클라이언트는 아래 값들을 기억해야한다.
    사용자 이름, 비밀번호, 난스, 난스 횟수, 인증세션과 관련된 알아보기 힘든 값들

- 난스가 만료되면,

  서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고,

  오래된 Authorization 헤더 정보를 받아들이는 것을 택할 수 있다.

  아니면 서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다.

  - 이때 응답 헤더의 `WWW-Authenticate`에 `stale=true`로 정의함으로써,
    서버는 클라에게 사용자 이름과 비밀번호를 새로 입력하도록 창을 띄울 필요 없이
    새 난스 값으로 요청을 다시 보내라고 말해줄 수 있다.



### 사전(preemptive) 인가

- 일반적으로 각 요청은 트랜잭션이 완료되기 전에 요청/인증 요구 사이클이 필요

- 만약 클라이언트가 다음 난스가 무엇이 될지 알고 있다면
  서버가 물어보기 전에 올바른 Authorization 헤더 생성 가능

<img src="ch13.다이제스트 인증.assets/ch13_5.png" alt="13. 다이제스트 인증 - HTTP: The Definitive Guide" style="zoom:50%;" />

#### 1. 다음 난스 미리 생성하기

```
Authentication-Info: nextnonce="<난스 값>"
```

- 장점 
  - 트랜잭션 속도 향상
- 단점
  - 다음 요청 받기 전에 반드시 다음 난스값을 받아야 하기 때문에 
    다중요청을 하는 파이프라인 사용 X 성능상 불이익이 더 커짐

#### 2. 제한된 난스 재사용

- 난스를 제한적으로 재사용 (5번만 사용 가능 / 10초간만 사용 가능)
- 장점
  - 클라이언트가 난스를 알고 있기 때문에 파이프라이닝 사용 가능
- 단점
  - 취약점과 성능 간의 트레이드오프가 있을 수 있음

#### 3. 동기화된 난스 생성

- 제 3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서
  클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록
  시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능

#### 4. 난스 선택

```
BASE64(타임스탬프 H(타임스탬프 : ETag : 개인키))
```

- 타임스탬프는 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값.
- ETag는 요청된 엔터티에 대한 ETag 헤더값
- 비밀 데이터는 서버만 알고 있는 데이터

- 서버는 클라 인증 헤더를 받은 뒤 재계산 해보고 
  클라이언트 인증 헤더의 난스 같지 않거나 타임스탬프가 오래되었다면 요청을 거절
- 재전송 공격을 방지하기 위해 사용된 난스나 요약을 받아들이지 않도록 결정도 가능
- 혹은 POST나 PUT 요청을 위해 일회성 난스나 요약을 사용하고
  GET 요청을 위해 타임스탬프를 사용할 수도 있다.

#### 5. 상호 인증

- 요청 메서드만 제외하고 A2 응답과 요청 방식 비슷

  - 요청

    ```
    # qop = auth-int
    A2 = <요청 메서드>:<url 지시자 값>:H(<요청 엔터티 본문>)
    ```

  - 응답

    ```
    # qop = auth-int
    A2 = <url 지시자 값>:H(<요청 엔터티 본문>)
    ```

    

## 3. 보호 수준(Quality of Protection) 향상

> qop

- 서버와 클라이언트가 어떤 보호 기법을 어느 수준으로 사용할 것인지 협상
  - 서버는 WWW-Authenticate 헤더에 qop 옵션을 목록 형태로 전송
  - 클라이언트는 옵션 중 자신의 요구와 맞는 것을 선택 후 Authorization 헤더에 전송

#### 메세지 무결성 보호 auth-int

- 무결성 보호가 적용되었을 때 계산되는 H(엔터티 본문)은 메세지 본문의 해시가 아닌 엔터티 본문의 해시이다



## 4. 실제 상황에 대한 고려

```
1. 다이제스트 인증 요구 `qop`: 가장 강력한 인증 매커니즘 선택하기
2. 오류 처리: `400 Bad Request`
3. 보호 공간 realm: 일반적으로 원 서버에 의해 할당되는 문자열
4. URI 다시 쓰기: 프락시는 구문만 고쳐서 URI를 다시 쓰기도 한다
5. 캐시: `must-revalidate`나 `public`
```



#### 1. 다중 인증 요구

- 서버는 한 리소스에 대해 여러 인증을 요구 가능

- 보통은 WWW-Authenticate에 qop필드에 쉼표로 구분하여 인증방법을 전송

- 클라이언트는 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택

- 다양한 인증 옵션을 제공할 때 클라이언트가 강력한 인증 메커니즘을 지원하지 못한다
  사용자에게 보안에 대해 경고 해야함

  

#### 2. 오류 처리

- 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져있는 경우`400 Bad Request`

- 비밀번호가 반복적으로 실패는 공격자의 시도가 있을 수 있으므로 로그 남기자

- URI 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같은지 확인
  프락시가 변조할 수도 있음

  

#### 3. 보호 공간(protectiom space)

- 영역 값은, 접근한 서버의 루트 URL과 결합하여, 보호 공간을 정의

- 영역의 값은 일반적으로 원 서버에 의해 할당되는 문자열

- 보호공간의 구체적인 계산

  - 기본인증
    - 클라이언트는 요청 URI와 그 하위의 모든 경로는 같은 보호 공간으로 가정
    - 서버로부터의 또 다른 인증 요구 없이 미리 리소스에 대한 인가를 받음

  - 다이제스트 인증

    - `WWW-Authenticate: domain` 필드는 보호 공간을 보다 엄밀하게 정의함

    - domain 필드는 작은 따옴표로 묶인 URI의 공백으로 분리된 목록

    - domain 목록의 모든 URI와 논리적으로 그 하위에 위치한 모든 URI는
      같은 보호 공간에 있는 것으로 가정

    - 만약 domain 필드가 없거나 빈 값이면
      인증을 요구하는 서버의 모든 URI이 보호 공간에 있는 것

      

#### 4. URI 다시 쓰기

- 프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 함

- 프락시가 URI를 변경할 수 있는 동시에
  다이제스트 인증은 URI 값의 무결성을 검사하므로 변경에 의해 실패 가능성 존재

  

#### 5. 캐시

- 어떤 공유가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우,
  두 Cache-Control 지시자가  `must-revalidate`나 `public` 중 
  하나가 응답에 존재하지 않으면 다른 요청에 대해 그 응답을 반환해서는 안됨
  -  `must-revalidate` Cache-Control 지시자를 포함한 경우
    - 캐시는 그 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용 할 것
    - 그러나 원 서버가 새 요청을 인증할 수 있도록,
      우선 그 요청의 헤더를 이용해서 재검사를 수행
  - `public` Cache-Control 지시자를 포함한 경우
    - 응답 엔터티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환될 수 있음



## 5. 보안에 대한 고려사항

#### 1. 헤더 부당 변경

- 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서
  **양 종단 암호화**나 헤더에 대한 **디지털 서명**이 필요할 것이다.

  

#### 2. 재전송 공격

- 재전송 공격은 누군가 어떤 트랜잭션에서 엿들은 인증자격을 다른 트랜잭션을 위해 사용하는 것

- GET 요청에 대한 이슈이지만 POST나 PUT 요청에 대한 재전송 공격 대비 예방책은 필수

- 재전송 공격을 완전히 피할 수 있는 한 방법은 매 트랜잭션마다 **유일한 난스 값을 사용**하는 것

  - 매 트랜잭션마다 서버는 유일한 난스를 타임아웃 값과 함께 발급

  - 발급된 난스 값은 그때의 트랜잭션과 주어진 타임아웃 값의 기간 동안만 유효

    

#### 3. 다중 인증 메커니즘

- 서버가 다중 인증 제도를 지원할때 선택지를 제공 할 때 인증의 강도는 선택지 중 **가장 약한 것과 같음**

- 클라이언트는 가능한 한 가장 강력한 인증제도를 선택되지만 현실적으로 불가능하다면,

  가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하여 해결

  - 모든 클라이언트가 우리가 선택한 강력한 인증 제도를 지원할 수 있다고 알려진 경우에만 실현 가능

    

#### 4. 사전(dictionary) 공격 

- 사전공격은 **전형적인 비밀번호 추측 공격**

- 악의적인 사용자는 트랜잭션을 엿들을 수 있고,
  난스/응답 쌍에 대해 (흔히 구할 수 있는) 비밀번호 추측 프로그램을 사용

- 크래킹하기 어렵도록 **복잡한 비밀번호를 사용**하거나 **비밀번호 만료 정책** 외에는 실질적으로 없음

  

#### 5. **악의적인 프락시와 중간 공격**(Man in the Middle Attack)

- 리다이렉션 기술과 차단 프락시의 도입으로 사용자는 그의 요청이 프락시를 통과한다는 것조차 모름
- 만약 프락시 중 하나가 악의적이거나 보안이 허술하면 클라이언트는 중간자 공격에 취약한 상태가 됨
- 해결할 좋은 방법은 없지만 가능한 해결책
  1. 클라이언트가 사용자에게 인증의 강도를 시각적으로 보여주는 것
  2. 클라이언트가 언제나 가능한 한 **가장 강력한 인증을 선택하도록** 설정하는 것, 등 존재
- 공격을 방어하는 제일 좋은 방법은 **SSL을 사용하는 것**



#### 6. 선택 평문 공격

- 다이제스트 인증을 사용하는 클라는 응답을 생성하기 위해 서버가 제공한 난스를 사용
- 악의적인 서버나 프락시가 있을 중간에 있을 경우 클라이언트 응답 계산을 하기 위한 난스를 제공 
  **= 선택적 평문 공격**
  1. 미리 계산된 사전 공격
     - 사전공격과 선택 평문 공격의 조합
       1. 공격서버는 미리 결정된 난스와 자주 쓰이는 비밀번호들로 응답의 집합을 생성하고 사전 생성
       2. 공격 서버/프락시는 트래픽을 차단 후 미리 결정된 난스를 클라로 전송
       3. 클라이언트로부터 응답 받으면 공격자는 대응되는 항목을 사전에서 찾음
       4. 대응 있으면 공격자는 특정 사용자의 비밀번호를 손에 넣은 것
  2. 자동화된 무차별 대입 공격
     - 많은 컴퓨터를 동원하여 주어진 범위에서 가능한 모든 비밀번호를 열거

- 공격으로 인한 위협을 방어하는 방법

  - 서버에서 제공된 난스 대신 **선택적 c난스 지시자**를 사용하여 응답
  - 만료 메커니즘이나 **강력한 비밀번호**를 강제하는 정책이 있으면 더 높은 방어가 가능

  

#### 7. 비밀번호 저장

- 다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것과 비교
- 비밀번호가 유출되는 문제를 완화하는 몇가지 방법
  1. 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다. 
  2. 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 극소화

