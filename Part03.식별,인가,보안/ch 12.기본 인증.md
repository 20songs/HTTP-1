# 인증

인증은 `당신이 누구인지 증명하는 것`이다. 완벽한 인증이란 없지만, 당신에 대한 여러 데이터는 당신이 누구인지 판단하는 데에 도움이 된다.



## 1. HTTP의 인증요구/응답 프레임워크

HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

![HTTP 인증](https://mdn.mozillademos.org/files/14689/HTTPAuth.png)

> `HTTP 인증요구/응답 과정`
>
> 1. 웹 애플리케이션이 HTTP 요청 메시지를 받는다.
> 2. 서버는 요청을 처리하는 대신 사용자가 누군인지 식별하기 위해 비밀번호 같은 개인 정보를 요구하는 `인증 요구`로 응답한다.
> 3. 인증 요구를 받은 클라이언트는 사용자에게 `인증 정보`를 물어 본다. 사용자는 자신의 인증 정보를 추가해 다시 요청을 보낸다.
> 4. 서버는 인증 정보가 맞지 않다면 다시 인증요구를 보내거나 에러를 반환한다. 인증 정보가 맞다면 문제없이 처리가 완료된다.



### 인증 프로토콜과 헤더

위 그림의 과정 중 2~4에는 `인증에 관련된 헤더`가 추가된 요청/응답 메시지가 전송된다. 이 헤더들의 형식과 내용은 `인증 프로토콜`에 따라 달라지며 HTTP는 인증 프로토콜에 맞추어 `고쳐 쓰고 확장할 수 있는` 프레임워크를 제공한다.

HTTP에는 `기본 인증`과 `다이제스트 인증` 두 가지의 공식적인 인증 프로토콜이 있는데 여기선 기본 인증에 대해 살펴 보자.



##### 서버의 인증 요구

서버가 인증을 요구할 때는 `WWW-Authenticate` 헤더를 포함한 `401 Unauthorized` 응답을 반환한다. 헤더의 문법은 다음과 같다.

```http
WWW-Authenticate: <type> realm=<realm>
```

기본 인증의 type은 `Basic`이며, `realm`은 보호되는 영역을 설명하거나 보호의 범위를 알리는데 사용된다. 같은 `realm`을 가지고 있는 페이지끼리는 동일한 `사용자 이름 & 비밀번호`로 인증이 가능하다.



##### 클라이언트의 인증 요청

응답을 받은 클라이언트는 `인코딩된 비밀번호`와 그 외 인증 파라미터들을 `Authorization` 헤더에 담아서 요청을 다시 보낸다.

```http
Authorization: <type> <credentials>
```

여기에서 `type`은 다시 한 번 필요하며, `credentials` 부분은 어떤 인증 스킴이 사용되는지에 따라 `인코딩`이 되어 있거나 `암호화`가 되어 있을 수 있다.



##### 서버의 응답

인증 요청이 성공적으로 완료되면, 서버는 `200 OK`를 반환하며 `추가적인 인증 알고리즘에 대한 정보`를 `Authentication-Info` 헤더에 기술할 수도 있다.

서버가 적절하지 않은 유효한 인증 정보를 수신한다면, 서버는 `403 Forbidden` 상태 코드로 응답하여야 합니다.



## 2. 보안 영역

HTTP는 각 리소스마다 다른 접근 조건을 다룰 수 있다. 웹 서버는 리소스를 `보안 영역(realm)` 그룹으로 나누며, 저마다 다른 사용자 권한을 요구한다.

```http
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Financials"
```

realm은 위와 같이 `해설 형식`으로 되어 있어서, 사용자가 권한의 범위를 이해하는 데 도움이 되어야 한다. 서버의 호스트명을 넣는 것도 유용할 수 있다.



# 기본 인증

기본 인증은 가장 잘 알려진 HTTP 인증 규약이다. 원래 HTTP/1.0에 기술되어 있었지만, `RFC 2617`로 옮겨졌다.



## 1. Base-64 사용자 이름/비밀번호 인코딩

HTTP 기본 인증은 사용자 이름과 비밀번호를 `콜론(:)`으로 이어 붙이고, `base-64` 인코딩 메서드를 사용해 인코딩 한다. 인코딩한 값을 `Authorization` 헤더에 담아서 요청을 보낸다.



##### Base-64

`Base-64` 인코딩은 바이너리, 텍스트, 국제 문자 데이터 등의 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다.

또한 사용자 이름과 비밀번호 문자를 섞을 수 있기 때문에 보안적인 문제를 예방하는 데에도 도움이 된다.



## 2. 프락시 인증

어떤 회사는 사용자들이 원 서버에 접근하기 전에 `프락시 서버`를 거치게 하여 사용자를 인증한다. 프락시 서버에서 접근 정책을 `중앙 관리` 할 수 있기 때문에, 회사 리소스 전체에 대해 `통합적인 접근 제어`를 하기 위해서 프락시 서버를 사용하면 좋다.

프락시 인증은 웹 서버의 인증과 헤더 이름과 상태 코드만 다르고 절차는 같다.

| 웹 서버                | 프락시 서버               |
| ---------------------- | ------------------------- |
| 비인증 상태 코드 : 401 | 비인증 상태 코드 : 407    |
| WWW-Authenticate       | Proxy-Authenticate        |
| Authorization          | Proxy-Authorization       |
| Authentication-Info    | Proxy-Authentication-Info |



# 기본 인증의 보안 결함

기본인증은 단순하고 편리하지만 안심할 수 없다. 그래서 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, `SSL` 같은 암호 기술과 혼용한다.



##### 인코딩과 디코딩이 쉽다

기본 인증은 사용자 이름과 비밀번호를 `쉽게 디코딩할 수 있는 형식`으로 네트워크에 전송한다. 사실상 비밀번호 그대로 보내는 것과 다름이 없다. 이를 방지하기 위해서는 모든 HTTP 트랜잭션을 `SSL 암호화 채널`을 통해 보내거나, 보안이 더 강화된 `다이제스트 인증` 같은 프로토콜을 사용하는 것이 좋다.



##### 재전송 공격

보안 비밀번호가 디코딩하기에 더 복잡한 방식으로 인코딩되어 있다고 하더라도, 여전히 제 3자가 중간에 가로챈 뒤 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있다. 기본 인증은 이러한 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다.



##### 동일한 사용자 이름과 비밀번호

사용자들은 여러 사이트에 동일한 사용자 이름과 비밀번호를 사용하기 마련이다. 때문에 보안이 중요하지 않은 애플리케이션이라고 하더라도 사용자의 정보가 노출되는 것은 위험하다.



##### 기존 의도와 다른 요청

메시지의 인증 헤더를 수정하지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 하지 않을 수 있다.



##### 가짜 서버

기본 인증은 `가짜 서버`에 취약하다. 사용자는 가짜 서버나 게이트를 검증된 서버로 착각할 수 있다. 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 수 있다.

종합해보면, 기본 인증은 다른 사람들이 보지 않기를 원하기는 하지만, 보더라도 치명적이지 않은 경우에 유용하다고 할 수 있다.