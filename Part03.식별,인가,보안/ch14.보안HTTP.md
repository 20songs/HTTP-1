[TOC]

# Part03.식별,인가,보안

## Chapter.14 보안 HTTP

### 서론: 14장의 목표

* 암호화의 이해
  * 암호
  * 대칭키 암호[비밀키 암호]
  * 공개키 암호[비대칭키 암호]
  * 서명
  * 인증서
* HTTPS의 이해
  * 안전한 HTTP의 조건
  * SSL 연결
  * 서버 인증서
  * 인증서 검사
  * 프락시

* 도움이 되는 게시글

  https://rsec.kr/?p=426

  생활코딩: https://opentutorials.org/course/228/4894

## 14.1 암호화

### 14.1.1 디지털 암호학

* 주요 개념

  * **암호**: 평문(텍스트)를 인코딩하는 알고리즘
  * **키**: 암호의 동작을 변경하는 매개변수, 숫자로 이루어짐
  * **대칭키 암호**: 인코딩과 디코딩이 같은 키
  * **비대칭키 암호**: 인코딩과 디코딩이 다른 키
  * **공개키 암호**: 확장성이 높은 암호기술
  * **디지털 서명**: 메시지의 위조, 변조를 막는 체크섬
  * **디지털 인증서**: 신원을 검증해주는 정보에 대한 신뢰할 만한 조직의 서명

* 용도

  * 전달 과정에 타인이 내용을 확인할 수 없도록 메시지를 암호화

  * 전달 과정에서 메시지의 내용이 보존되도록 변조 방지
  * 메시지와 트랜잭션을 보낸 저자를 증명

### 14.1.2 암호

* 평문인 메시지를 암호문으로 인코딩 하는 방법
  * 반대의 경우 디코딩, 복호화라고 함

* 예시: `rot3`
  * meet me at the pier at midnight
    * phhw ph dw wkh slhu dw plgqlikw
  * 알파벳 순서의 +3 으로 암호화, -3으로 복호화 한 방식

#### 암호 기계

* 기존의 암호 체계에서는 간단한 알고리즘을 사용하였음
  * 암호첩(code book)을 기반으로 연필/종이를 사용하여 암호화, 복호화를 진행함
* 기계의 도입으로 새로운 암호화 방식이 등장함
  * 예시: 2차 세계 대전 당시 애니그마 암호 기계

#### 키가 있는 암호

* 코드 알고리즘, 기계와 더불어 암호화 동작 방식을 결정하는 키
  * 누군가 기계를 훔쳐도 올바른 다이얼 없이 동작하지 않도록 설계
* 키의 값에 따라 다른 출력을 생성함
  * `rot N` > 3이 아닌 N을 기준으로 작동



### 14.1.3 디지털 암호

* 두 가지 중요 발전
  * 복잡한 인코딩과 디코딩 알고리즘이 가능
  * 매우 큰 키를 지원하는 것이 가능하여 키 값에 따라 수조 개 이상의 가상 암호 알고리즘을 생성할 수 있음
* 함수 표현
  * C = E(P,e)
  * P = D(C,d)

### 14.1.4 대칭키 암호

* 대칭키 암호에서는 e와 d가 동일함
* 대표적 알고리즘
  * DES, Triple-DES, RC2, RC4

#### 키 길이, 열거 공격

* 열거 공격
  * 무차별로 모든 키 값을 대입하는 공격
* 키의 길이
  * 비트로 표현
  * 40비트 > 1995년 기술 수준의 컴퓨팅 계산 속도로 2초
  * 128비트 > 1995년 기준으로 10**15년
* 단, 키의 길이 이외 요소에 의해 취약해질 수 있음
  * 키의 후보, 키의 생성 과정, 암호화 알고리즘 등에 대해 공격자가 정보를 갖고 있는 경우, 범위가 줄어들 수 있음

#### 공유키 발급

* 대칭 키 방식은 키를 서로 공유해야 함
  * 사전에 비밀키가 공유되어야 함
  * 원거리에서 전달이 어려움
  * N 명의 노드가 통신하는 경우 N**2 의 개수가 필요함
    * 관리상의 이유

### 14.1.5 공개키 암호

* 두 개의 비대칭 키를 사용
  * 인코딩을 위한 키: 공개 키
  * 디코딩을 위한 키: 비밀 키
  * 두 가지는 서로 다른 역할을 할 수 있어 공개키로도 디코딩, 비밀키로도 인코딩이 가능함
* 장점
  * 공개적으로 인코딩 키를 배포할 수 있음
  * N**2 이 아닌 동일한 인코딩 키로 메시지를 암호화 할 수 있음
  * 원거리에서 전달이 가능함
* 공개키 암호의 강건성
  * 키의 전달이 공개적으로 이루어질 수 있어야 한다
  * 암호문의 일부를 뺴앗겨도 안전해야 한다
  * 평문과 이를 암호화한 암호문이 있어도 안전해야 한다

#### RSA

* 공개키의 기준을 충족하는 알고리즘

  * 큰 수의 소수를 찾는 방식

    

### 14.1.6 디지털 서명

* 메시지의 내용이 위조되지 않았음을 증명하는 역할
* 메시지를 작성한 저자가 누구인지 입증하는 역할
* 공개키 기반의 암호화 방식

#### 암호 체크섬

* 서명의 동작 방식
  * 메시지를 작성
  * 메시지를 정제하여 고정된 길이의 요약(digest)으로 만든다
  * 작성자의 개인 키(비밀키)를 매개변수로 '서명' 함수를 적용한다
  * 서명이 계산되면 메시지의 끝에 서명 결과를 붙여 전송한다
  * 공개키를 이용해 역함수를 적용한 후 내용의 무결성 여부를 따진다

### 14.1.7 디지털 인증서

* 공개키를 보증하는 인증
  * 신분증과 같은 역할
  * 인증서에 등록한 공개키, 공개키에 대한 사용자 정보를 암호화함
  * 인증 기관은 이를 비밀키를 이용하여 서명함
  * 인증 기관의 공개키를 가진 사람이 이를 복호화하게 되면 거래하고자 하는 당사자의 공개키와 내용을 얻게 됨
  * 이를 통해 메시지 내용을 다시 해독하는 과정을 거침
* 내가 전달 받은 공개키가 정말 그 사람으로부터 온 것임을 중간에 연결해주는 장치

#### 인증서 내부 내용

* 대상의 이름(사람, 서버, 조직 등)
* 유효기간
* 인증서 발급자(인증서를 보증하는 기관)
* 인증서 발급자의 디지털 서명 [ 비밀키로 서명한 결과 값을 붙임]

#### x.509 내용

* p.370 참조
* 디지털 인증서에 대한 표준을 제정 중에 있으며 책에 제시된 것은 다소 예전 내용에 해당함
* 이를 기반으로 한 대표적인 인증서
  * 웹 서버 인증서
  * 클라이언트 이메일 인증서
  * 소프트웨어 코드사인 인증서
  * 인증기관 인증서

#### 인증서 사용하기

* 서버 인증 시 포함된 필드
  * 웹 사이트의 이름과 호스트 명
  * 웹 사이트의 공개키
  * 서명 기관의 이름
  * 서명 기관의 서명
* 브라우저는 해당 필드를 통해 웹 서버에 대한 검증을 수행함
  * 브라우저는 보통 신뢰할 만한 인증 기관에 대한 정보와 그에 대한 공개키를 갖고 있음
  * 서명기관이 브라우저에 등록되지 않으면 경고 메시지가 나옴

## 14.2 HTTPS

### 14.2.1 안전한 HTTP 요건

* 서버인증
  * 위조된 서버가 아닌 진짜라는 것은 증명
* 클라이언트 인증
  * 가짜가 아닌 진짜 사용자임을 증명
* 무결성
  * 데이터의 위조나 수정이 없어야 함
* 암호화
  * 도청에 대한 걱정이 없이 대화할 수 있어야 함
* 효율
  * 알고리즘이 충분히 빨라야 함
* 편재성
  * 프로토콜이 다 지원되어야 함
* 관리상 확장성
  * 누구든 어디서든 보안 통신이 가능해야 함
* 적응성
  * 최선의 보안 방법이어야 함 [계산 속도 등]
* 사회적 생존성
  * 사회의 문화적, 정치적 요구 만족

### 14.2.2 HTTPS 구조

* HTTP - TCP - IP - 네트워크 인터페이스
  * HTTP와 TCP 사이에 소켓이 삽입됨
  * SSL(안전 소켓 계층)이라고 통칭하는 보안 소캣은 
    현재 옛날의 SSL을 계승한 TLS(전송 계층 보안)를 사용하지만
    명칭은 SSL로 통일하고 있음

* 연결에는 공개키
* 전송에는 대칭키

![views](img/SSL 소켓.png)

![Crocus](img/SSL 통신과정.png)

### 14.2.3 HTTPS 스킴

* http://
  * 80번 포트로 연결합니다
* https://
  * 443번 포트로 연결합니다
  * SSL 보안 연결을 위해 핸드셰이크를 진행합니다
  * 만약 SSL의 바이너리한 메시지가 80번 포트로 동작하면 커넥션이 닫힐 것

### 14.2.4 보안 전송 셋업

* HTTPS의 보안 절차
  * 웹 서버의 443 포트로 연결됨
  * 암호법 매개변수와 교환 키를 협상하기 시작함
  * SSL계층을 초기화함
  * 핸드셰이크 완료 후 보안 계층과의 커넥션이 생김
  * HTTP 요청/TCP를 암호화하여 메시지를 수신, 송신함
  * SSL이 닫히고 TCP 커넥션이 닫힘

### 14.2.5 SSL 핸드셰이크

* 절차
  * 프로토콜 버전 번호 교환
  * 양쪽이 알고 있는 암호 알고리즘을 선택
  * 양쪽의 신원을 인증
  * 채널을 암호화 하기 위한 임시 세션 키 [비밀키, 대칭키] 생성
* 공개키 방식은 데이터 전송에 비효율적 연산이 많음
  * 따라서 핸드 셰이크 과정을 무사히 수행하고 나면 데이터 암호화는 비밀키 방식으로 진행함

### 14.2.6 서버 인증서

* 클라이언트 인증서는 보통 요구되지 않기에 서버 인증서가 요구됨

* 서버 인증서의 내용

  | 인증서 일련번호      | 35:DE:F4:CF            |
  | -------------------- | ---------------------- |
  | 인증서 유효기간      | 2003년 9월 7일 수요일  |
  | 사이트 조직 이름     | 죠의 하드웨어 온라인   |
  | 사이트 DNS 호스트 명 | www.joes-hardware.com  |
  | 사이트 공개 키       | lskdjfoaisejrkajsdlkjf |
  | 인증서 발급자 이름   | RSA 데이터 보안        |
  | 인증서 발급자 서명   | jonsoen                |

### 14.2.7 사이트 인증서 검사

* 서버 인증서를 검사하는 방법과 순서
* 날짜 검사
  * 인증서 유효 기간을 확인
* 서명자 신뢰도 검사
  * 인증서를 발급한 인증 기관에 대한 검사
  * 브라우저가 가지고 있는 신뢰할 만한 서명 기관의 목록에 없으면 경고 메시지
  * 해당 인증서는 간접적으로 여러 연결 고리를 타고 확인되면 괜찮음
* 서명 검사
  * 공개키를 적용하여 체크섬을 비교함
* 사이트 신원 검사
  * 인증서 도메인 이름을 확인

### 14.2.8 가상 호스팅

* 가상 호스트로 운영되는 사이트
  * 하나의 서버에 여러 호스트 명으로 운영되는 사이트
  * 보안 트래픽을 다루는 것이 상당히 까다로움
  * 서버 인증서를 발급한 호스트는  ://ww.cajun-shop.securesites.com인 경우 
  * Cajun-shop.com으로 거래를 요청하면 경고가 나타날 수 있음
  * 이에 보안 트랜잭션을 시작하면 모든 요청 메시지를 securesites.com으로 리다이렉트해야 함

### 14.2.9 프록시와 터널링

* 프락시는 암호화 된 HTTP 헤더, 본문을 읽을 수 없음
  * 프락시가 혼란스러워 짐
  * 이를 위해 터널링을 사용함
* HTTPS SSL 터널링
  * CONNECT라는 확장 메서드를 사용하여 터널링을 요청함
  * 호스트와 포트를 전달하면 프락시는 연결을 수행함
  * 이 후 연결이 이루어지면 (핸드셰이크가 성공했다면) SSL 데이터를 주고 받을 수 있음

### 14.2.10 Open SSL 예시

* 대표적인 예시

  * 오픈 소스

  * p.381 참고

    

* 과정

  * (1) SSL 라이브러리 초기화
  * (2) 서버의 호스트 명을 IP 주소로 변환
  * (3) 서버의 443 포트로 TCP 커넥션
  * (4) TCP 커넥션을 통해 SSL 핸드세이크 개시
  * (5) 협상을 통해 선택된 암호를 출력
  * (6) 서버 인증서를 출력
    * 인증서 검사를 포함함
  * (7) 핸드셰이크 완료 후 SSL을 통해 HTTP 요청
  * (8) SSL 스택으로부터 HTTP 응답을 읽음
  * (9) 커넥션을 닫고 정리함