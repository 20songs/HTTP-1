# 캐시의 필요성



## 1. 불필요한 데이터 전송

복수의 클라이언트가 자주 접근하는 원 서버 페이지들 즉, 똑같은 바이트들이 반복해서 서버에서 클라이언트로 이동한다. 개발자라면 반복은 피해야 하는 법. 캐시를 이용해 서버 응답을 보관하고 보내줄 수 있지 않을까?



## 2. 대역폭 병목

많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 `더 넓은 대역폭`을 제공한다. 즉, 서버 근처보다 클라이언트 근처의 네트워크 속도가 빠르다는 뜻이다. 따라서 상대적으로 클라이언트에 가까운 곳에 있는 캐시로부터 사본을 가져온다면 성능을 대폭 개선할 수 있을 것이다.

> 대역폭 vs 전송 속도
>
> 쉽게 얘기하면 대역폭은 초당 전송될 수 있는 `비트의 최대량`이고 전송 속도는 초당 전송되는 `현재 비트의 평균 속도`를 나타낸다.
>
> [참조 링크](https://sonne21c.tistory.com/entry/%EC%A0%84%EC%86%A1%EC%86%8D%EB%8F%84bit-rate%EC%99%80-%EB%8C%80%EC%97%AD%ED%8F%ADBandwidth%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)



## 3. 갑작스런 요청 쇄도 (Flash Crowds)

캐싱은 `갑작스런 요청 쇄도`에 대처하기 위해 특히 중요하다. 갑작스런 사건으로 인해 많은 사람이 거의 동시에 동일한 문서에 접근할 때 이런 일이 발생한다. 설날에 카카오톡의 트래픽이 급증하여 먹통이 되곤 했던 경우가 바로 이런 경우에 속한다.



## 4. 거리로 인한 지연

다른 요인을 차치하더라도 거리가 멀면 느릴 것이라는 유추는 쉽게 해볼 수 있다. 캐싱을 이용한다면 그 거리를 대폭 줄일 수 있겠다라는 것도 말이다.



# 적중과 부적중

캐시의 필요성은 알겠고 모든 문서를 캐시를 통해 받고 싶다는 생각이 들 수 있다. 하지만 캐시의 용량은 한정되어 있기 때문에 캐시가 `모든 문서의 사본을 저장하지는 않는다`. 또한 모든 문서의 사본을 저장했다고 하더라도 문서를 항상 최신 상태로 유지해야 한다는 숙제는 여전히 남는다.

캐시가 요청받은 사본을 가지고 있는 경우를 `캐시 적중(cache hit)`, 없다면 `캐시 부적중(cache miss)`이라고 부른다. 캐시는 각각의 과정을 어떻게 처리할까.



## 1. 재검사(Revalidation)

원 서버의 콘텐츠는 언제든지 변경될 수 있다. 캐시는 `HTTP 재검사`를 통해 자신이 가지고 있는 사본이 최신인지 체크해야 한다.

캐시는 자신이 원할 때 언제든지 재검사를 할 수 있지만 보통 문서가 수백만 개에 달하기 때문에 그렇게 하다간 대역폭이 남아나지 않을 수 있다. 그래서 대부분의 캐시는 `클라이언트가 사본을 요청`했고 그 사본이 `검사를 할 필요가 있을 정도로 오래되었을 때` 재검사를 시행한다.



##### 재검사 시행

캐시는 재검사가 필요할 경우, 서버에 `작은 재검사 요청`을 보낸다. 콘텐츠가 변경되지 않았다면 서버는 `아주 작은 304 Not Modified` 응답을 보낸다. 응답을 받은 캐시는 사본에 아직 신선하다고 다시 표시한 후 클라이언트에게 전달한다. 이를 `재검사 적중` 혹은 `느린 적중`이라고 한다. `느린 적중`이라 함은 순수 캐시 적중보다는 느리지만 캐시 부적중보다는 빠르기 때문이다.



##### 재검사 방법

HTTP에서 캐시된 객체를 재확인하기 위한 도구 중 가장 많이 쓰이는 것이 `If-Modified-Since` 헤더다. 서버에게 보내는 GET 요청에 이 헤더를 포함하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.

캐시의 `GET If-Modified-Since` 요청이 서버에 도착했을 때 세 가지의 상황이 일어날 수 있다.



### 재검사 적중

위에서 얘기했듯 서버 객체가 변경되지 않았을 경우 서버는 작은 `HTTP 304 Not Modified` 응답을 보낸다.



### 재검사 부적중

`서버 객체 != 캐시된 사본`인 상황이면 서버는 콘텐츠 전체와 함께 평범한 `HTTP 200 OK` 응답을 보낸다.



### 객체 삭제

만약 `서버 객체가 삭제`되었다면 서버는 `404 Not Found` 응답을 보내며, 캐시는 보관하고 있던 사본을 삭제한다.



## 2. 적중률

`캐시 적중률` 혹은 `문서 적중률`이라고도 부르는데 `캐시가 요청을 처리하는 비율`이다. 적중률이 높을수록 캐시 적중이 많았다는 뜻이다. 0에서 1까지 값으로 표현되기도 하고 퍼센트로 표현되기도 한다. 오늘날 적중률 40% 정도면 괜찮은 편이라고 한다.



## 3. 바이트 적중률

캐시 적중률이 높더라도 문서의 크기에 따라 전체 트래픽에 기여하는 정도가 다를 수 있다. 크기가 작은 문서만 적중하고 큰 문서는 부적중한다면 캐시 적중률은 높지만 트래픽에는 크게 기여하지 못하는 상황이 발생할 수 있다.

이를 보완하기 위해 `바이트 단위 적중률`로 캐시 적중률을 표현하기도 하는데, `캐시를 통해 제공된 모든 바이트의 비율`을 표현한다. 적중률이 높을수록 많은 바이트가 캐시에서 왔다는 뜻이다.



##### 문서 적중률 & 바이트 단위 적중률

둘 다 캐시 성능에 대한 유용한 지표다. 문서 적중률을 개선하면 `전체 대기시간(지연)`이 줄어들고, 바이트 단위 적중률을 개선하면 `대역폭 절약`을 최적화한다.



## 4. 적중과 부적중의 구별

HTTP 자체에서는 받은 응답이 적중인지 부적중인지 알 수 있는 방법을 제공하지 않는다. 어떤 상용 프락시 캐시는 `Via 헤더`에 추가 정보를 붙이기도 하는데, 클라이언트에서 알아내는 한 가지 방법은 `Date 헤더`를 이용하는 것이다. 응답의 Date 헤더 값을 현재 시각과 비교해서 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다. 이 밖에 `Age 헤더`를 이용하는 방법도 있다.



# 캐시 토폴로지

> 토폴로지?
>
> 네트워크에서 장치들이 어떤 형태로 `배치` 또는 `구성`이 되어있는가를 말한다.



## 1. 개인 전용 캐시

`한 명에게만 할당된 캐시`를 말한다. 대부분의 브라우저는 개인 전용 캐시를 내장하고 있어, 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓는다.

사용자는 임의로 캐시 사이즈와 설정을 수정할 수 있다. 또한 이미 저장된 캐시를 살펴보는 것도 가능하다.



## 2. 공용 프락시 캐시

여러 사용자가 공유하는 프락시 서버다. 공용 프락시 캐시는 `로컬 캐시에 문서를 제공`하거나, `사용자의 입장에서 서버에 접근`한다. 여러 사용자가 접근하기 때문에 개인 전용 캐시에 비해 많은 용량을 담을 필요가 있다.

사용자는 브라우저에서 `수동 프락시`를 지정하거나 `프락시 자동설정 파일`을 설정함으로써 프락시 캐시를 사용하도록 설정할 수 있다. 또한 `인터셉트 프락시`를 사용함으로써 HTTP 요청이 브라우저의 설정없이 강제로 캐시를 통하도록 할 수도 있다.



## 3. 프락시 캐시 계층들

![proxy_topology](https://access.redhat.com/webassets/avalon/d/Red_Hat_Network_Satellite-5.4-Proxy_Installation_Guide-ko-KR/images/e04a769067e941f82d018fb36b98ebe2/rhns-proxy_topology3.png)

작은 캐시(클라이언트 주위 캐시)에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시로 요청이 가도록 만드는 방식이 합리적일 때가 많다. 이 구조에서는 계층 상단으로 갈수록 더 크고 고성능인 프락시 캐시가 존재한다.

이 구조에서는 프락시 연쇄가 길어질수록 속도는 느려진다. 따라서 대부분의 네트워크 아키텍트들은 두 개 혹은 세개의 프락시만 거치도록 스스로 제한한다.



## 4. 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 `복잡한 캐시망`을 만든다. 캐시망 내의 프락시는 복잡한 방법으로 서로 대화하여 요청을 부모 캐시로 보낼 것인지, 원 서버로 보낼 것인지 등의 결정을 동적으로 내린다.



##### 캐시망 내부의 캐시들이 하는 일

- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거하여, 특정 부모 캐시를 동적으로 선택
- 부모 캐시에게 가기 전, 로컬에서 캐시된 사본 검색
- 다른 캐시들의 부분적 접근을 허용하되, 그들의 캐시를 통한 `인터넷 트랜짓(Internet Transit)`은 허용하지 않음

이를 이용해 서로 다른 조직들이 상호 합의하에 서로의 캐시를 연결하여 서로를 찾아볼 수 있게 하기도 한다. 이와 같이 선택적인 피어링을 지원하는 캐시를 `형제 캐시`라고 부르며 HTTP는 이를 지원하지 않기 때문에 `ICP`, `HTCP`같은 프로토콜을 이용해 HTTP를 확장해서 사용한다.



# 캐시 처리 단계

HTTP 메시지를 처리하는 캐시의 기본적인 단계를 알아보자.



## 1. 요청 받기

네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다. `고성능 캐시`는 여러 개의 커넥션들의 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.



## 2. 파싱

메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다. 캐싱 소프트웨어의 헤더 필드 처리 및 조작을 쉽게 하기 위함이다.



## 3. 검색

파싱해서 알아낸 URL이 로컬 사본에 있는지 검사한다. 로컬에 없을 경우, 상황이나 설정에 따라 `원 서버`나 `부모 프락시`에서 가져오거나 실패를 반환한다.

캐시된 객체는 보통 응답에 대한 정보를 담고 있지만, 복잡합 캐시들은 `HTTP 1.1 콘텐츠 협상`에 사용하기 위해 `클라이언트 요청 헤더`의 사본도 보관한다.



## 4. 신선도 검사

HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다. 이 기간이 넘어가면 객체를 `신선하지 않은` 것으로 간주해 서버와 재검사를 해야 한다.



## 5. 응답 생성

캐시된 `서버 응답 헤더`를 바탕으로 응답 헤더를 생성한다. 캐시는 클라이언트에 맞게 헤더를 조정해야 한다. 클라이언트가 기대하는 HTTP 버전, 사본의 신선도 정보, 프락시 캐시를 거쳐갔는지에 대한 여부(Via 헤더) 등을 포함한다.

하지만 캐시는 `Date 헤더`를 조정해서는 안 된다. 이 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것이기 때문이다.



## 6. 전송

응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려준다. 모든 프락시 서버들처럼, 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있다.

고성능 캐시는 종종 `로컬 저장장치`와 `네트워크 I/O 버퍼` 사이에서 `문서의 콘텐츠 복사`를 피함으로써 데이터를 효과적으로 전송하고자 한다.



## 7. 로깅

대부분의 캐시는 `로그 파일`과 `캐시 사용`에 대한 통계를 유지한다. 각 캐시 트랜잭션이 완료된 후 캐시는 캐시 적중, 부적중 횟수 및 다른 지표들에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL 등의 항목을 추가한다.

가장 많이 쓰이는 로그 포맷은 `스퀴드 로그 포맷(Squid log format)`과 `넷스케이프 확장 공용 로그 포맷(Netscape extended common log format)`이지만, 많은 캐시 제품이 `커스텀 로그 파일`을 허용한다.



# 사본을 신선하게 유지하기

캐시된 사본이 원 서버의 문서와 일치하지 않을 수 있다. 문서는 매 순간 바뀔 수 있기 때문이다. 캐시된 사본이 지속적으로 신선하게 유지하는 게 필요하다. HTTP는 어떤 메커니즘을 통해 사본을 신선하게 유지할까.



## 1. 문서 만료

HTTP는 `Cache-Control`과 `Expires`라는 특별한 헤더들을 이용해 원 서버가 각 문서에 `유효기간`을 붙일 수 있게 해준다. 이 기간 동안 콘텐츠는 신선한 것으로 간주된다.

만료된 문서는 반드시 서버와 재검사가 이루어져야 한다. 클라이언트 요청에 캐시되었거나 서버와의 검사가 이루어지지 않은 리소스는 거부하겠다는 헤더가 없는 경우, 캐시는 만료되지 않은 문서를 `서버와의 접촉 없이` 제공할 수 있다.



## 2. 유효기간과 나이

서버는 `HTTP/1.0+ Expires`나 `HTTP/1.1 Cache-Control: max-age` 응답 헤더를 이용해서 유효기간을 명시한다.

- `Cache-Control: max-age` : 문서의 `최대 나이`를 정의한다. 문서가 처음 생성된 이후부터 이 시간(초 단위)이 흐르기 전까지 문서는 신선하다고 간주된다.
- `Expires` : `절대 유효기간`을 명시한다. 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구한다.

```http
Cache-Control: max-age=484200
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```



## 3. 서버 재검사

캐시된 문서가 만료되었다는 것이 그 문서가 원 서버의 것과 다르다는 것을 의미하지는 않는다. 다만, 그 문서를 재검사할 필요가 있다는 뜻이다. 이를 `서버 재검사`라고 부른다.

- 재검사 결과 콘텐츠가 `변경되었다면`, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
- 재검사 결과 콘텐츠가 `변경되지 않았다면`, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.

`문서가 만료되었을 때만` 캐시는 서버에 재검사를 요청하기 때문에 신선한 콘텐츠를 공급하면서도 서버 트래픽을 절약하고 사용자 응답 시간을 절약할 수 있다.

HTTP 요청을 받은 캐시는 다음 중 하나를 반환하는 작업을 하게 된다.

- `충분히 신선한` 캐시된 사본
- `재검사`가 이루어진 캐시된 사본
- 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
- `경고 메시지`가 부착된 캐시된 사본(부정확하다면)



## 4. 조건부 메서드와의 재검사

서버에 조건부로 요청을 보낼 수도 있다. 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 `다른 경우에만` 객체 본문을 보내달라고 요청하는 것이다.

`조건부 GET`은 GET 요청에 특별한 조건부 헤더를 추가함으로써 시작된다. 총 다섯 가지를 정의하고 있는데, 그 중 캐시 재검사를 할 때 가장 유용한 `If-Modified-Since`와 `If-None-Match` 두 가지를 살펴보자.



### If-Modified-Since: 날짜 재검사

가장 흔히 쓰이는 캐시 재검사 헤더는 `If-Modified-Since`이다. 흔히 `IMS` 요청으로 불리는데, 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.

- `문서가 주어진 날짜 이후에 변경된 경우`
  GET 요청이 평범하게 성공한다.
- `변경되지 않은 경우`
  서버는 작은 `304 Not Modified` 응답 메시지를 클라이언트에게 돌려준다. 효율을 위해 본문은 보내지 않으며, 갱신이 필요한 헤더들은 갱신해서 보내준다. 예를 들어, 재검사가 이루어졌으므로 `새로운 만료 날짜`를 넣어서 보내 준다.



##### Last-Modified 헤더

If-Modified-Since 헤더는 서버 응답 헤더의 `Last-Modified 헤더`와 함께 동작한다. 원 서버는 제공하는 문서에 `최근 변경 일시`를 붙인다. 서버는 이를 `Last-Modified 헤더`에 담아 캐시에게 제공하고 캐시는 이를 다시 `If-Modified-Since` 요청 헤더에 담아 서버에 재검사 요청을 보낸다.



##### If-Modified-Since 문자열 비교

몇몇 웹 서버는 `If-Modified-Since 헤더`의 시간을 비교하지 않고 `문자열의 일치 여부`를 검사한다. 예를 들어 `일련 번호` 같은 것을 최근 변경 일시로 사용한다면, 시간을 비교할 수는 없겠지만 캐시 관련 동작에는 아무런 지장이 없다.




### If-None-Match: 엔터티 태그 재검사

다음과 같은 상황에서는 최근 변경 일시 재검사가 적절히 행해지기 어려울 수 있다.

- 어떤 문서는 일정 시간 간격으로 수정되지만 실제로는 같은 데이터를 포함하고 있는 경우가 있다. `내용에는 아무런 변화가 없지만` 최근 변경 일시는 계속 달라진다.
- 어떤 문서들의 변경은 그 데이터를 다시 읽어들이기엔 너무 `사소한 것`일 수 있다. (철자, 주석 등의 변경)
- 어떤 서버들은 그들이 갖고 있는 문서의 최근 변경 일시를 `정확하게 판별할 수 없다.`
- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.

`If-None-Match 헤더`가 이를 보완할 수 있는데 `ETag(엔터티 태그)`와 함께 쓰인다. 캐시는 `If-None-Match 헤더`에 현재 갖고 있는 문서의 `ETag`를 담아 서버로 조건부 요청을 보낸다. 서버는 엔터티 태그가 변화되었다면 `200 OK` 응답을 새 콘텐츠 및 새 엔터티 태그와 함께 반환하고 아니라면 `304 Not Modified` 응답을 반환한다.

캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 서버에게 알리기 위해 여러 개의 엔터티 태그를 포함시킬 수도 있다.



#### 약한 검사기와 강한 검사기

캐시는 사본의 신선도를 파악하기 위해 `엔터티 태그`와 `최근 변경일시`를 사용한다. 이 둘을 `캐시 검사기`라고 한다.

엔터티 태그는 강한 것이 있고 약한 것이 있다. `강한 엔터티 태그`는 콘텐츠가 바뀔 때마다 바뀐다. `약한 엔터티 태그`는 콘텐츠가 조금 변경되었더라도 `중요한 의미가 변화되었을 때`만 바뀐다. 어느 정도의 변화를 허용하는 것이다.

둘의 구분은 약한 검사기에 접두사로 `W/`를 붙이는 것으로 이루어지며, 조건부 특정범위 가져오기 같은 몇몇 동작은 약한 검사기로는 불가능하기 때문에 구분이 필요하다.

원 서버는 서로 다른 두 엔터티에 대해 강한 엔터티는 무조건, 약한 엔터티는 서로 의미가 다를 때 재활용해서는 안 된다.



## 5. ETag or Last-Modified

각각의 검사기는 언제 사용해야 할까. 서버의 응답에 따라 다르다. 서버가 보낸 응답의 형태에 따라 검사가 이루어져야 하며 두 가지 형식이 모두 포함되었을 때는 두 방법을 모두 사용해서 검사가 이루어져야 한다.

서버의 경우 HTTP/1.1 원 서버는 불가능하지 않다면 `엔터티 태그 검사기`를 보내야 한다. 둘 다 보내는 것도 선호된다.

캐시나 서버가 두 가지 형식의 헤더를 모두 받았다면, 서버는 두 조건을 모두 부합했을 때만 304 응답을 반환해야 한다.



# 캐시 제어

HTTP는 캐시의 저장 기간을 제어할 수 있게 해준다.



## 1. no-cache & no-store 응답 헤더

`no-cache`와 `no-store` 헤더는 캐시가 `검증되지 않은 캐시된 객체`로 응답하는 것을 막는다.

```http
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache
```

`no-store`가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 `금지`한다. 캐시는 여타 프락시 서버처럼, no-store 응답을 전달하고 나면 객체를 삭제한다.

`no-cache`가 표시된 응답은 캐시가 사본을 만들 수는 있지만 클라이언트에게 제공하기 전 항상 서버와 `재검사`를 해야 한다.

`Pragma: no-cache` 헤더는 HTTP/1.0+와의 `하위호환성`을 위해 HTTP/1.1에 포함되어 있다. HTTP/1.0에 대응해야 하는 경우가 아니라면 Cache-Control을 사용해야 한다.



## 2. Max-Age 응답 헤더

리소스가 최신 상태라고 판단할 최대 시간을 지정한다. 서버로부터 응답을 받았을 때부터 흐른 시간을 기준으로 한다. 또한 `s-maxage`는 max-age처럼 동작하지만 공용 캐시에서만 작동한다.



## 3. Expires 응답 헤더

HTTP 명세에는 `expires 헤더`를 사용하지 않는 것을 권장하고 있다. expires 헤더는 `실제 만료 날짜`를 지정하기 때문에 서버의 시간들이 동기화가 되어 있어야 하지만 그렇지 않은 경우가 많다.

응답 내에 `max-age` 혹은 `s-maxage` 디렉티브를 지닌 `Cache-Control 헤더`가 존재할 경우, Expires 헤더는 [무시](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Expires)된다.



## 4. Must-Revalidate 응답 헤더

캐시가 만료 정보를 엄격하게 따르기를 원할 때 이 응답 헤더를 사용할 수 있다. `Cache-Control: must-revalidate` 응답 헤더는 캐시가 만료된 사본을 서버와의 `최초의 재검사` 없이는 제공해서는 안 됨을 의미한다.

캐시가 must-revalidate 신선도 검사를 시도했을 때 서버가 먹통이라면, 반드시 `504 Gateway Timeout error`를 반환해야 한다.



## 5. 휴리스틱 만료

만약 응답이 `max-age`나 `Expires` 중 어떤 헤더도 포함하지 않는다면, 캐시는 `경험적인 방법(heuristic)`으로 최대 나이를 계산한다. 어떤 방법이든 사용될 수 있지만 계산한 결과 `24시간`보다 클 경우 `Heuristic Expiration 경고(경고 13) 헤더`가 응답 헤더에 추가되어야 한다.

유명한 휴리스틱 만료 알고리즘의 하나인 `LM 인자 알고리즘`은 문서의 `최근 변경 일시`를 이용해 최대 나이를 계산한다. 문서가 최근에 바뀐 것일수록 자주 바뀐다고 가정하여 캐시 기간을 짧게 가져가는 것이 주된 원리이다.

문서의 최근 변경 일시조차 없다면, `캐시의 만료 기본값`으로 설정된다. 생각보다 이런 경우가 많기 때문에 신중하게 선택하는 것이 필요하다.



## 6. 클라이언트 신선도 제약

지금까지는 서버에서 제어하는 방법이었다면 이번엔 `브라우저`에서 제어하는 방법이다. 웹 브라우저는 브라우저나 프락시 캐시의 `신선하지 않은 콘텐츠`를 강제로 갱신시켜 주는 `리프레시`나 `리로드` 버튼을 가지고 있다. `Cache-Control` 요청 헤더가 추가된 GET 요청을 발생시켜서, 강제로 재검사하거나 원 서버로부터 콘텐츠를 가져온다.

또한 클라이언트는 `Cache-Control` 요청 헤더를 이용해 만료를 더 엄격하게 혹은 느슨하게 만들 수 있다. 자세한 내용은 [여기](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control)에서 `캐시 요청 디렉티브` 부분을 참조하자.

