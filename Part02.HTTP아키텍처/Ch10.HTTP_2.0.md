[TOC]

# Part02.HTTP 아키텍처

## Chapter.10 HTTP/2.0

### 서론: HTTP/2.0의 8번째 초안

* HTTP/2.0의 초안이 계속해서 수정되고 있음
  * 책은 8번재 초안에 대한 내용



### 10.1 HTTP2.0의 등장 배경

---

* HTTP/1.1의 메시지 포맷
  
  * 구현의 단순성과 접근성에 최적화
  * 성능 면에서 비효율
    * 커넥션 하나 - 요청 / 응답 하나
    * 응답을 받지 못하면 심각한 회전 지연에 빠지게 됨
    * 4장의 병렬 커넥션, 파이프라인 커넥션은 이를 보완하는 도구이지만 근본적인 해결책이 아님
  
* 대안

  > 모든 대안은 회전 지열을 줄이는 것을 목표로 하였음

  * HTTP-NG (HTTP 그룹)
  * WAKA (HTTP/1.1 의 저자)
  * S+M(MS)
  * SPDY(구글)
    * SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하고 있음

### 10.2 개요

---

* 개요
  * 서버 - 클라이언트 사이의 TCP 커넥션 위에서 동작함
  * 클라이언트가 TCP 커넥션을 초기화 함
  * 길이가 정의된 프레임에 요청/응답이 담김
  * 프레임은 스트림을 통해 보내지며
  * 하나의 커넥션에 여러 개의 스트림 / 하나의 스트림에 한 쌍의 요청/응답을 처리함
  * 여러 요청과 응답을 동시 처리하는 구조가 가능해짐
* 서버 푸시
  * 서버가 능동적으로 클라이언트에게 필요하다고 생각되는 리소스를 보낼 수 있음
* 호환성
  * 메시지의 의미를 최대한 유지함
  * 일부 문법이 바뀌고 있음

### 10.3 HTTP/1.1과의 차이점

---

#### 10.3.1 프레임

| R(2) | 길이(14)          | 종류(8) | 플래그(8) |
| ---- | ----------------- | ------- | --------- |
| R(1) | 스트림 식별자(31) |         |           |
|      | 스트림 페이로드   |         |           |

* 8바이트의 헤더 + 최대 16,383 바이트 크기의 페이로드로 구성
* R
  * 예약된 2비트  / 1비트 필드
  * 반드시 0 값이며 받는 쪽에서는 이 값을 무시함
* 길이
  * 페이로드의 길이를 나타내는 14비트 Uint(무부호 정수)
  * 프레임 헤더의 길이를 제외
* 종류
  * 프레임의 종류
* 플래그
  * 8비트
  * 프레임 종류에 따라 다른 값을 가짐
* 스트림 식별자
  * 31비트 스트림 식별자
  * 0은 커넥션 전체와 연관된 프레임을 의미함

* 프레임 종류
  * DATA
  * HEADERS
  * PRIORITY
  * RST_STREAM
  * SETTINGS
  * PUSH_PROMISE
  * PING
  * GOAWAY
  * WINDOW_UPDATE
  * CONTINUATION

#### 10.3.2 스트림과 멀티플렉싱

* 스트림
  * 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
  * 클라이언트가 스트림을 생성 - 요청 - 서버가 해당 스트림에 응답 - 스트림 close
* 장점
  * 커넥션 관리 문제를 피할 수 있음
  * 하나의 커넥션에 여러 요청을 보낼 수 있기 때문에 커넥션 제한 문제를 해결할 수 있음
* 특징
  * 우선순위 기능이 존재하여 제한된 네트웨트 대역폭에서 중요한 리소스를 요청하는 스트림에 더 높은 우선순위를 부과할 수 있음
    * 선택적 기능(의무x)
  * 스트림 식별자
    * 홀수면 클라이언트
    * 짝수면 서버
    * 새로 만들어지는 것은 이전의 스트림 혹은 예약된 스트림보다 항상 큰 값을 가짐
    * 이를 어길 경우 ERROR CODE 반환
  * TCP 패킷
    * 통신을 통해 확인하는 절차 없이 그냥 만들어버림
  * 스트림 식별자의 고갈
    * 커넥션을 다시 맺으면 초기화 된다

#### 10.3.3 헤더 압축

* 기존 HTTP/1.1
  * 압축이 없음
  * 과거 웹페이지는 헤더가 복잡하지 않았으나
  * 현대 웹페이지 하나를 보기 위해 요청이 수십 ~ 수백에 달하기 때문에
  * 헤더의 크기가 회전 지연과 대역폭 모두에 실질적인 영향을 끼침
* 압축 방식
  * HPACK 명세의 헤더 압축 방법 사용
  * 압축 콘텍스트를 사용
    * 수신 측은 어떤 경우라도 반드시 압축을 해제해야함

#### 10.3.4 서버 푸시

* PUSH_PROMISE
  * 서버가 클라이언트의 요청에 대해 어떤 리소스를 요구할 지 파악가능한 경우
    * HTML이면 CSS, JS등의 리소스를 푸시
  * PUSH_PROMISE를 보냄
    * 클라이언트가 RST_STREAM을 보내면 푸시 거절 / 스트림 닫힘
* 주의 사항
  * 프락시가 데이터를 안 보내거나 서버가 푸시하지 않은 데이터를 보낼 가능성
  * 안전하고 캐시 가능하고 본문을 포함하지 않은 요청만 푸시할 것



### 10.4 알려진 보안 이슈

---

#### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)

* HTTP/1.1 메시지로 읽으려고 하는 경우
  * HTTP/2.0은 바이너리 인코딩이 되기 때문에 
  * HTTP/1.1 기준에서 불법, 위조된 메시지로 오역되기 쉬움
* HTTP/1.1 메시지를 2.0이 읽는 경우
  * 문제 없음

#### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

* HTTP/2.0은 긴 커넥션을 염두
  * 커넥션이 오래 유지되면 개인 정보가 유출 될 가능성이 있음
  * 현재의 HTTP 프로토콜도 갖고 있는 문제이지만 커넥션 유지 기간에 따라 위험도가 달라짐
