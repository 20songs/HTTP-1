[TOC]

# Part02.HTTP 아키텍처

## Chapter.8 통합점: 게이트웨이, 터널, 릴레이

### 서론: 8장의 목표

* 게이트웨이
  * 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
    * 프로토콜 게이트웨이
    * 리소스 게이트웨이

* 애플리케이션 인터페이스(API)
  * 서로 다른 형식의 웹 애플리케이션이 통신하는 데 사용
    * CGI, API
    * SOAP, XML
    * REST, JSON
* 터널
  * HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송
* 릴레이
  * 단순한 HTTP 프락시
  * 한 번에 한 개의 홉에 데이터를 전달하는 데 사용



### 8.1 게이트웨이

---

* 게이트웨이란
  * 리소스와 애플리케이션을 연결하는 역할
  * HTTP 이외의 정의해둔 Interface로도 요청-응답이 가능함
* 역할
  * 클라이언트 요청에 대해 응답을 보내는 포털 같이 동작
  * 애플리케이션이 게이트웨이에 요청을 처리하도록 전달함
  * 동적 콘텐츠 생성 or 데이터 베이스 질의(query)
* 특징
  * HTTP 트래픽을 다른 프로토콜로 자동 변환 [일종의 통역 기능]
* 예시
  * `HTTP  클라이언트` <-> `FTP 게이트웨이` <-> `FTP 서버`
  * `HTTPS  클라이언트` <-> `보안 게이트웨이` <-> `HTTP 서버`
    * 단 게이트웨이에 해당 서버 인증서가 설치되어야 함
  * `HTTP  클라이언트` <-> `애플리케이션 서버 게이트웨이 (CGI, API)`
    * 주식 시세를 보거나 웹에서 물건을 사는 경우 앱 서버 게이트웨이를 방문하는 것

#### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

* 웹 게이트웨이
  
  * 한 쪽은 HTTP 프로토콜, 다른 한 쪽은 다른 프로토콜
  
    * 프락시 중 두 가지를 변환하는 경우가 있는데 이는 양쪽 모두 HTTP로 변환시키기 때문에 기술적으로 프락시에 해당함
  
  * `<클라이언트 프로토콜>/<서버 프로토콜>`
  
    * HTTP/NNTP 게이트웨이
  
      > HTTP 클라이언트와 NNTP 사이에 있는 게이트웨이를 지칭할 때의 표기법
  
  * 서버 측 게이트웨이
  
    * 클라이언트와 HTTP 통신
    * 서버와 외래 프로토콜 통신
  
  * 클라이언트 측 게이트웨이
  
    * 클라이언트와 외래 프로토콜 통신
    * 서버와 HTTP 통신



### 8.2 프로토콜 게이트웨이

---

* 브라우저의 설정 - 프락시 설정
  * 설정된 값이 아닌 일반적인 HTTP 트래픽에는 영향이 없음
  * 조건에 해당하면 그 HTTP 요청은 게이트웨이로 보내지게 됨

#### 8.2.1. HTTP/* : 서버 측 웹 게이트웨이

* 클라이언트의 요청: HTTP

  * 서버에게 외래 프로토콜 전환

* 예시

  * FTP

  | 명렁어                    | 뜻                        |
  | ------------------------- | ------------------------- |
  | USER anonymous / PASS joe | USER,PASS로 서버에 로그인 |
  | CWD /pub                  | 디렉토리 변경             |
  | TYPE A                    | ASCII 다운로드 형식 지정  |
  | MDTN 00-index.txt         | 최근 수정 시간            |
  | PASV                      | 수동형 데이터 검색        |
  | RETR 00-index.txt         | 객체를 검색               |

* 데이터 커넥션을 맺은 후 데이터를 전송받아 전달

#### 8.2.2. HTTP/HTTPS : 서버 측 보안 게이트웨이

* 클라이언트의 요청: HTTP
  * 서버에게 웹 요청을 암호화

```
GET http://www.cnn.com/ HTTP/1.0
Host: www.cnn.com
User-agent: Superbrowser 4.2
```

```
laskdjfisjelrndgnasdijsijer/;asldfjosiejrlksadjflkjaseori
asdkfjastoaiejrlksadma]s[da]fa[2]/ASLDJFOIJXLKVASDJ
u|OAISUEROPASMLVISIERJ
```

* 서버에게 SSL(HTTPS)을 통한 HTTP암호화 메시지 전달

#### 8.2.3. HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이

* 보안 가속기로 유명
* 클라이언트: SSL(HTTPS)의 HTTp 암호화 메시지 요청
  * 게이트웨이: 복호화 하여 HTTP 방식으로 변환
  * 보통 웹 서버도 SSL 암/복호화 모듈이 있으나 게이트웨이의 하드웨어는 복호화 알고리즘에 특화 된 하드웨어를 내장한다고 함
  * 이로 원 서버의 부하가 줄어든다



### 8.3 리소스 게이트웨이

---

* 어플리케이션 서버
  * `클라이언트` > `HTTP 요청` > `API`(`어플리케이션 서버`) > `어플리케이션 연결` > `응답 데이터 전송`
* CGI(Common Gateway Interface)
  * 애플리케이션 게이트웨이에서 유명했던 최초의 API
  * 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행
  * 프로그램의 출력 수집 후 HTTP 응답으로 회신하는 표준화 된 인터페이스 집합
* CGI의 동작
  * 게이트웨이를 거처야 하는 리소스 요청이 들어온 경우
  * 헬퍼 애플리케이션을 생성하여 요청을 처리함 [게이트웨이 프로세스]

#### 8.3.1 공용 게이트웨이 인터페이스(CGI)

* 최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장
  * 동적 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공하는 데 사용
* 장점
  * CGI 애플리케이션이 서버와 분리되며 (웹 서버를) 수많은 언어로 구현할 수 있음
  * 단순한 구조이기 때문에 대부분 지원하는 기능
* 단점
  * 매 리소스 요청에 따라 새로운 프로세스(헬퍼 애플리케이션) 생성
  * 부하가 꽤 커서 서버 장비에 부담을 줌

#### 8.3.2 서버 확장 API

* 서버 확장 API
  * 서버 자체의 동작을 바꾸거나 서버의 처리 능력을 끌어 올리는 기능 등을 지원
  * 프로그래머가 자신의 모듈, 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있는 인터페이스
* 예시
  * 프론트페이지 서버 확장 by MS
  * 도서 업체가 API를 제공한다면 파트너 혹은 공공 개발자가 리소스에 대한 접근 권한을 활용하여 도서 재고 확인 및 온라인 거래 어플리케이션을 만드는 것



### 8.4 애플리케이션 인터페이스와 웹 서비스

---

* REST 방식의 JSON 포맷
  * 웹 애플리케이션이 많은 서비스를 제공함에 따라 HTTP를 통한 연결이 더 중요해짐
  * 둘 사이의 프로토콜 인터페이스를 맞춰야 데이터 교환이 일어남
  * 통신에 필요한 웹 표준, 프로토콜 집합이 개발되었는데
  * 초기 SOAP 방식의 XML
    * Simple Object Access Protocol
    * eXtensible Markup Langue
  * 현재 REST 방식의 JSON



### 8.5 터널

---

* HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법
  * HTTP 커넥션에 HTTP가 아닌 트래픽을 전송
  * 다른 프로토콜을 HTTP위에 올릴 수 있음
  * 방화벽 기능을 뚫을 수 있다!

#### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

* CONNECT 메서드를 사용해서 강제로 연결하는 방식

  * 데이터를 무조건 전달하도록 함 (프로토콜이 맞지 않아도)

* CONNECT 요청

  ```
  CONNECT home.netscape.com:443 HTTP/1.0
  User-agent: Mozilla/4.0
  ```

  * 시작줄을 제외하고 HTTP 메서드와 같음
  * 요청 URI에 호스트와 포트를 모두 기술

* CONNECT 응답

  ```
  HTTP/1.0 200 Connection Establisehd
  Proxy-agent: Netscape-Proxy/1.1
  ```

  * 일반적인 응답과 유사함
  * 단, Content-Type을 명시할 필요가 없음
  * 모든 콘텐츠를 바이트 형식으로 전달하기만 할 뿐이기 때문

#### 8.5.2 데이터 터널링, 시간, 커넥션 관리

* 데이터 터널링
  * 게이트웨이가 데이터의 전달을 볼 수 없기 때문에
  * 패킷의 순서, 흐름에 대한 정보는 없어짐
* 시간
  * CONNECT 방식을 사용하는 경우 보다 빨리 데이터를 전송할 수 있음
  * 요청에 대한 응답이 오기 전에 보낼 수 있기 때문
  * 단, 게이트웨이가 이를 적절히 처리해주지 못하면 실패한다
  * 또한 게이트웨이가 클라이언트에게 인증을 요구할 수 있는데 데이터 크기가 전송 폭을 넘어버리면 커넥션이 자동으로 끊긴다고 한다
* 커넥션 관리
  * 한 쪽의 커넥션이 끊어지면 그곳에서 출발한 데이터는 일단 보내진다
  * 그리고 다른 한쪽도 끊긴다

#### 8.5.3 SSL 터널링

* SSL 같이 암호화 된 프로토콜은 낡은 방식의 프락시, 필터링 라우터를 통과하지 못함
  * 이에 웹 터널을 사용하여 HTTP 커넥션으로 SSL 트래픽을 전송하는 방식을 고안해냄
* 보안 웹서버에서는 SSL 트래픽이 바로 전송됨
  * 일반 SSL 커넥션을 지나기 전에는 HTTP 메시지로 터널링하여 HTTP 포트인 80에 전송함
* 악의적인 트래픽이 유입되는 수단이 될 수도 있음

#### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

* HTTP/HTTPS 게이트웨이의 문제점
  * 클라이언트 - 게이트웨이 사이에 일반 HTTP 커넥션을 맺으면 보안이 적용되지 않는다
  * 프락시가 게이트웨이의 HTTPS 트랜잭션을 수행받아 인증을 담당하기 때문에 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없다.
  * 게이트웨이가 SSL을 완벽히 지원해 HTTPS 서버에 전달해야 한다
* SSL 터널링을 사용하면
  * 프락시가 SSL을 인증하지 않고 암호화 된 트랜잭션을 그대로 터널링하기만 하면 됨
  * HTTPS 서버가 인증을 담당하게 됨

#### 8.5.5. 터널 인증

* HTTP의 기능 중 하나
  * CONNECT 요청을 받은 경우 게이트웨이가 인증 요구를 return 시킴
  * 인증에 대한 True가 오면 터널 연결을 맺어줌

#### 8.5.6 터널 보안에 대한 고려사항

* 게이트웨이가 오픈된 터널링을 감시, 검증할 수 없으므로
  * 터널의 오용을 최소화 하기 위해 HTTPS 전용 포트인 443 같은 잘 알려진 특정 포트만 터널링 채널로 허용해야 함



### 8.6 릴레이

---

* 맹목적으로 바이트를 전달하는 연결 수단
  * HTTP 명세를 완전히 준수하지 않는 Simple 형태의 프락시
  * 유용할 때가 있음
* 주의
  * 데이터 간 상호 운용 문제
  * Keep-Alive 커넥션 행(hang) 문제
* Keep-alive 커넥션 행(hang) 문제
  * 클라이언트가 `Connection:Keep-alive` 요청을 보냄
  * 릴레이는 Connection을 이해하지 못함
  * Connection 헤더는 홉과 홉 사이에만 사용하는 헤더이기 때문에 이를 전달하게 되면 서버는 릴레이와 keep-alive 상태를 유지함
  * 서버가 끊지 않으면 릴레이가 끊지 않음 따라서 커넥션이 끊길 때를 기다리면서 계속 커넥션을 맺는 hang 상태에 빠짐
  * 이 상태에서 클라이언트는 먼저 요청에 대한 응답을 받고 다음 요청ㅇ르 보내는데 릴레이가 이를 인지하지 못함
  * 연결은 된 상태에서 두 번째 요청부터 아무 작업도 진행되지 않음
* 상호 운용 문제
  * 이 문제는 언제나 잠재하고 있기 때문에 릴레이 대신 프로토콜을 준수하는 프록시 사용을 권장